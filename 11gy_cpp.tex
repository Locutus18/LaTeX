\documentclass[a4paper,11.5pt]{article}
\usepackage[textwidth=170mm, textheight=230mm, inner=20mm, top=20mm, bottom=30mm]{geometry}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{amsmath, amsthm,amssymb,paralist,array, ellipsis, graphicx}
\usepackage[table]{xcolor}
%\usepackage{marvosym}

\usepackage{listings}
\lstset{
	language=C++, 
	basicstyle=\ttfamily, 
	keywordstyle=\color{blue}\ttfamily, 
	stringstyle=\color{red}\ttfamily,
	tabsize = 4
}

\makeatletter
\renewcommand*{\mathellipsis}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\dotsb@}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\@cdots}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\ellipsis@default}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	\ellipsis@after\relax}
\renewcommand*{\ellipsis@centered}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisaftergap
	\ellipsis@after\relax}
\AtBeginDocument{%
	\DeclareRobustCommand*{\dots}{%
		\ifmmode\@xp\mdots@\else\@xp\textellipsis\fi}}
\def\ellipsisgap{.1em}
\def\ellipsisbeforegap{.05em}
\def\ellipsisaftergap{.05em}
\makeatother

\usepackage{hyperref}
\hypersetup{
	colorlinks = true	
}

\begin{document}
	%%%%%%%%%%%RÖVIDÍTÉSEK%%%%%%%%%%
	\setlength\parindent{0pt}
	\def\s{\hspace{0.2mm}\vphantom{\beta}}
	\def\Z{\mathbb{Z}}
	\def\Q{\mathbb{Q}}
	\def\R{\mathbb{R}}
	\def\C{\mathbb{C}}
	\def\N{\mathbb{N}}
	\def\Ra{\overline{\mathbb{R}}}
	
	\def\sume{\displaystyle\sum_{n=1}^{+\infty}}
	\def\sumn{\displaystyle\sum_{n=0}^{+\infty}}
	
	\def\narrow{\underset{n\rightarrow+\infty}{\longrightarrow}}
	\def\limn{\displaystyle\lim_{n\to +\infty}}
	\def\limx{\displaystyle\lim_{x\to +\infty}}
	
	\theoremstyle{definition}
	\newtheorem{theorem}{Tétel}[subsection] 
	
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definíció} 
	\newtheorem{example}[theorem]{Példa} 
	\newtheorem{task}[theorem]{Feladat} 
	\newtheorem{note}[theorem]{Megjegyzés}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{center}
		{\LARGE\textbf{C++}}
		
		{\Large Gyakorlat jegyzet}
		
		11. óra.
	\end{center}
	A jegyzetet \textsc{Umann} Kristóf készítette \textsc{Brunner} Tibor  előadásán. (\today)
	\section{Objektum orientált programozás}
	Objektum orientált programozásnál e hármat várjuk el:
	\begin{itemize}
		\item enkapszuláció
		\item kód újrafelhasználás
		\item adat elrejtés
	\end{itemize}
	Az, hogy egy adott nyelv ezt hogyan valósítja meg, az a saját maga dolga. Vannak nyelvek, melyek jobban alkalmasan objektum orientált programozásra, mint mások. Példaképp, a C nyelvre is mondhatjuk, hogy objektum orientált, bár nincs benne örökölődés, és nem igazán kézenfekvő az adatok elrejtése sem (bár lehetséges). Nyilvánvalóan ennél egyel praktikusabb nyelvek is léteznek, példaképp Java, és nyilván a c++ is, melyek sokkal erősebb nyelvi eszközökkel rendelkeznek ezek megvalósítására.
	
	Fontos, hogy az objektum orientáltság fogalmát ne csak az osztályokhoz kössük!
	
	\medskip
	Tekintsük az alábbi kódot:
	\begin{lstlisting}
class Sikidom
{
	int x;
	int y;
public:
	Sikidom(int x, int y) : x(x), y(y) {}
	double terulet() const
	{
		//...
	}
};
	\end{lstlisting}
	Itt a célunk egy általános síkidom megadása, azonban bajban vagyunk, hisz nem tudjuk megmondani, hogy épp egy tetszőleges síkidomnak milyen lesz a területe. Hozzunk létre egy kört, hisz annak a területét meg tudjuk adni! Próbáljuk ehhez használni az öröklődést: vegyünk át mindent, ami a Síkidomban van, elvégre minden kör egy síkidom!
	
	\begin{lstlisting}
class Kor : public Sikidom
{
	double r;
public:
	double terulet() const
	{
		return r * r * 3.14;
	}
};
	\end{lstlisting}
	Az öröklődés következtében \texttt{Kor} osztály \texttt{Sikidom} összes adattagját és metódusát átveszi. Fentebb látható az öröklődés szintaktikája: kettőspont, és utána egy öröklődési típus (ez esetben \texttt{public}, erről nemsoká lesz bővebben szó). Mondhatjuk azt is, hogy a \texttt{Kor} \textit{az egy} \texttt{Sikidom}, hisz minden, a \texttt{Sikidom}ra jellemző tulajdonsággal rendelkezik.
	\begin{note}
		Nagyon fontos, hogy a 3,14-nél pontot és nem vesszőt használunk. Ha ezt írnánk:
		\begin{lstlisting}
int i = 1, 2, f(), g();
		\end{lstlisting}
		
		Akkor rendre a vessző paraméter előtti tag mindig kiértékelődik, és utána értékeli ki a következőt. A végén az egész azzal lesz ekvivalens, mintha simán azt írnánk, hogy \texttt{int i = g();}
		
		Egy fél mondat erejéig jegyezzük meg azt is, hogy lebegőpontos számokat sose hasonlítsunk össze! Jusson eszünkbe, ami Numerikus Módszereken hangzik el: minden lebegőpontos szám tartalmazhat egy kis pontatlanságot.
		\begin{lstlisting}
for (double d = 0; d != 1; d += 0.1)
{
	std::cout << d << std::endl;
}
		\end{lstlisting}
		Itt bár azt várnánk, hogy a kimenet \texttt{0 0.1 0.2 ...} legyen, legnagyobb valószínűséggel végtelen ciklusba futunk. Ez amiatt van, hogy a 0.1 (várhatóan) tartalmaz egy kis pontatlanságot, és így hiába írja ki  a programunk hogy \texttt{d} értéke 1, az várhatóan csak nagyon közel lesz hozzá.
	\end{note}
	Az, hogy publikusan örököltünk (erre volt a \texttt{public} kulcsszó), azt jelenti, hogy egy {altípus}-t (\textit{subtype}) hoztunk létre. 
	Ezt azt is jelenti, hogy minden helyre, ahol \texttt{Sikidom}-ot szeretnénk használni, \texttt{Kor}-t is használhatunk.
	
	Van egy apróbb probléma a fenti kóddal azonban: Az osztály azon adattagjai, melyek \texttt{private}-ként vannak deklarálva, csak az adott számára elérhetőek.
	
	Ez probléma hisz mi \texttt{Kor}-t azért hoztuk létre, hogy speciálisabb feladatokat tudjuk végrehajtani \texttt{Sikidom} tulajdonságaival, azonban \texttt{x} és \texttt{y} privát, és csak \texttt{Sikidom} tud hozzáférni. Írjuk át ezt protectedre:
\begin{lstlisting}
class Sikidom
{
protected:
	int x;
	int y;
public:
	Sikidom(int x, int y) : x(x), y(y) {}
	double terulet() const {}
};
\end{lstlisting}
	A \texttt{protected} tagokhoz csak az adott osztály fér hozzá, és azon osztályok, melyek ebből örökölnek. Nem csak publikusan tudunk örökölni, \texttt{protected}-del, és \texttt{private}-el is. Az alábbi táblázat mutatja, hogy az származott osztály (\textit{derived class}) milyen adattagokhoz fér hozzá a bázisosztályból (\textit{base class}) különböző öröklődési típusok esetén:
	\begin{center}
		\begin{tabular}{|c||c|c|c|}
			\hline
			Öröklődés típusa:&public&protected&private\\
			\hline
			\hline
			Saját adatok/metódusok& \cellcolor{green!20}igen&\cellcolor{green!20}igen&\cellcolor{green!20}igen\\
			\hline
			Örökölt adatok/metódusok (public)&\cellcolor{green!20}igen&\cellcolor{green!20}igen&\cellcolor{green!20}igen\\
			\hline
			Örökölt adatok/metódusok (protected)&\cellcolor{green!20}igen&\cellcolor{green!20}igen&\cellcolor{green!20}igen\\
			\hline
			Örökölt adatok/metódusok (private)&\cellcolor{red!20}nem&\cellcolor{red!20}nem&\cellcolor{red!20}nem\\
			\hline
		\end{tabular}
	\end{center}
	Ez pedig mutatja egy adott adattag/metódus védettségét öröklődés után:
	\begin{center}
		\begin{tabular}{|c||c|c|c|}
			\hline
			Öröklődés típusa:&public&protected&private\\
			\hline
			\hline
			Örökölt adatok/metódusok (public)&\cellcolor{green!20}public&\cellcolor{orange!20}protected&\cellcolor{red!20}private\\
			\hline
			Örökölt adatok/metódusok (protected)&\cellcolor{orange!20}protected&\cellcolor{orange!20}protected&\cellcolor{red!20}private\\
			\hline
			Örökölt adatok/metódusok (private)&\cellcolor{red!20}private&\cellcolor{red!20}private&\cellcolor{red!20}private\\
			\hline
		\end{tabular}
	\end{center}
	Picit térjünk visza a fenti értékadáshoz, mert ott azért van még mit megbeszélni.
	\begin{lstlisting}
Kor k;
Sikidom s;
s = k; //ok
	\end{lstlisting}
	Azt már letisztáztuk, hogy \texttt{Kor} \texttt{Sikidom} altípusa, de azonban ez akkor is két különbötő típus, hogyan lehet, hogy nem kapunk fordítási idejű hibát?
	
	A válasz az, hogy a fordító meg tudja oldani e két típus közötti értékadást. Mivel \texttt{Kor}-ben benne van maga \texttt{Sikidom} is, ezért meghívja az ahhoz tartozó értékadó operátort, és a \texttt{Kor}-ben lévő \texttt{Sikidom}-ot adja majd értékül.
	
	Ez azonban magával hordozza azt is, hogy minden információ, ami \texttt{Kor}-respecifikus (pl. sugár (\texttt{r})) elveszik. Ez az un. \textit{slicing}. Ebben az esetben, lévén a fordító generálta nekünk az értékadó operátort, és az alapértelmezetten minden adattagra meghívja az arra definiált értékadó operátort, gyakorlatilag ez fog történni:
	\begin{lstlisting}
s.x = k.x;
s.y = k.y;
	\end{lstlisting}
	
	Ezt a \textit{slicing} dolgot meg tudjuk kerülni, ha egy pointert hozunk létre: Hisz egy \texttt{Sikidom}-ra mutató pointer mutathat \texttt{Kor}-re is, és mivel az ''csak'' mutogat, nem fog levágni semmit. 
	\begin{lstlisting}
Kor k;
Sikidom *sp = &k;
	\end{lstlisting}
	Így minden adathoz, ami \texttt{Kor}-ben \texttt{Sikidom}-tól lett örökölve, hozzá tudunk férni \texttt{sp}-n keresztül. Fontos megjegyeznünk azonban, hogy egy \texttt{Sikidom} típusú pointer csak ''\texttt{Sikidom}nyi'' adattagokat/metódusokat tud kezelni.
	
	Mi fog történni, ha meghívjuk a \texttt{terulet} metódust?
	\begin{lstlisting}
Kor k;
Sikidom *sp = &k;
sp->terulet();
	\end{lstlisting}
	Itt azt fogjuk tapasztalni, hogy \texttt{Sikidom} függvénye fog meghívódni. Ennek oka az, hogy \texttt{sp} statikus típusa (\textit{static type}) az \texttt{Sikidom}, és hatékonyság végett alapértelmezetten mindig a statikus típushoz tartozó függvényt hívódik meg. Egy pointernek azonban van un. dinamikus típusa is (\textit{dynamic type}), ami ebben az esetben \texttt{Kor} lesz. A dinamikus típust csak futási időben lehet ismert, hisz lehetetlen azt megállapítani fordítási időben, hogy milyen típusú objektumra fog mutatni az \texttt{sp}. Ha mindig a dinamikus típus szerint hívná meg a program függvényeket, annak nagy futási idejű költsége lenne. Ahhoz, hogy rákényszerítsük a fordítót arra, hogy a dinamikus típus szerint fordítson, használnunk kell a \texttt{virtual} kulcsszót.
	%TODO miért szar a láncolt lista: túl költséges a processzorba pakolás ...
\begin{lstlisting}
class Sikidom
{
protected:
	int x;
	int y;
public:
	Sikidom(int x, int y) : x(x), y(y) {}
	virtual double terulet() const //virtualis!
	{
		//...
	}
};

class Kor : public Sikidom
{
	double r;
public:
	double terulet() const
	{
		return r * r * 3.14;
	}
};
\end{lstlisting}
	Picit bánthat minket az, hogy hogyan jöhet elő ez a probléma, ugyanis úgy tűnik, mintha sértenénk a \textit{one definition rule}-t, hisz létrehoztunk két függvényt azonos visszatérési értékkel és paraméterlistával: a kiút az, hogy itt felüldefiniálás (\textit{override}) fog bekövetkezni, azaz a \texttt{Kor}-béli \texttt{terulet} le fogja árnyákolni a \texttt{Sikidom} \texttt{terulet} függvényét. Viszont ez a leárnyékolás nem ér sokat, ha nincs \texttt{virtual} kulcsszó, és ha egy \texttt{Sikidom} típusú pointerrel akarjuk ezt használni.
%TODO this is a complete mess. Számomra teljesen érthetetlen ezzel a kódrészlettel mi volt a cél.
%	Próbáljunk megírni egy sítábor programot, melyben azt oldjuk meg, hogy a kétszobás ágyakban vagy 2 fiú, vagy 2 lány aludjon!
%\begin{lstlisting}
%#include <iostream>
%
%class Sielo
%{
%public:
%	virtual void szobatars(Sielo*)
%	{
%		std::cout << "sielo";
%	}
%};
%
%class Lany : public Sielo
%{
%public:
%	void szobatars(Sielo*)
%	{
%		std::cout << "valamilyen sielo";
%	}
%	void szobatars(Lany*)
%	{
%		std::cout << "lany sielo";
%	}
%};
%
%class Fiu : public Sielo
%{
%public:
%	void szobatars(Sielo*)
%	{
%		std::cout << "valamilyen sielo";
%	}
%	void szobatars(Fiu*)
%	{
%		std::cout << "fiu sielo";
%	}
%};
%
%int main()
%{
%	Lany l1, *l2;
%	Fiu *f;
%	l1.szobatars(l2); //lany sielo
%	endl(std::cout);
%	Sielo *s = &l1;
%	s->szobatars(f); //lany sielo
%}
%\end{lstlisting}
%	Itt sikerült elírni, hogy a fiúnak lány legyen a szobatársa. Figyeljük meg, hogy két különböző paraméterű \texttt{szobatars} metódust írtunk, de csak az virtuális, mely egy \texttt{Sielo}-t vár. Ezért, mivel minden \texttt{Fiu} \textit{az egy} \texttt{Sielo}, teljesen szabályos lesz a \texttt{szobatars(Sielo*)} függvényhívás.
	%TODO ezt még Roberto mondta, de nem mernék megesküdni rá.
	\begin{note}
		Egy függvény öröklődés után nem marad virtuális. Azaz, ha \texttt{Kor}-ből örökölnénk, és szintén felül szeretnénk írni \texttt{terulet}-et, \texttt{Kor}-ben is virtuálisnak kell deklarálnunk a függvényt.
	\end{note}
	
	\smallskip
	Szánjunk pár szót meglévő kód módosításáról, ha polimorfizmusról is van szó.
	\begin{lstlisting}
void f(Kor* k)
{
	//...
}
	\end{lstlisting}
	Lehet, az implementáció egy pontján úgy döntünk, hogy ez várjon inkább síkidomokat.
	\begin{lstlisting}
void f(Sikidom* k)
{
	//...
}
	\end{lstlisting}
	Ezzel semmi gond nem lesz, ugyanis ha mi \texttt{f}-nek továbbra is \texttt{Kor}öket fogunk adni, egy \texttt{Sikidom} típusú pointer tud még mutatni \texttt{Kor} típusra. Ennek a tanulsága az, hogy paramétereknél \textbf{felfelé} az öröklődési láncon lehet haladni, lefelé nem, hiszen egy síkidomra mutató pointer mutathat körre, de fordítva nem. Továbbá, ha visszatérési értéknél:
	\begin{lstlisting}
Sikidom f(...) {}
	\end{lstlisting}
	úgy döntünk, inkább kört adunk vissza:
	\begin{lstlisting}
Kor f(...) {}
	\end{lstlisting}
	nem lesz semmi gond, hisz itt is, minden kör \textit{az egy} síkidom. Azaz ha módosítjuk egy függvény visszatérési értékét, \textbf{lefelé} haladjunk az öröklődési ágon.
	\begin{lstlisting}
Kor *k;
Sikidom * sp = f(k);
	\end{lstlisting}
	Bajban lennénk, ha \texttt{Sikidom}-nál egy általánosabb osztályt adna vissza \texttt{f}.
	\medskip
	
	\subsection{Cast-ok}
	
	Néha abba a kellemetlen helyzetbe kerülhetünk, hogy van egy adott pointerünk/referenciák, és a dinamikus típusa \texttt{Kor}, azonban statikus típusa \texttt{Sikidom}, de mégis fontos, hogy \texttt{Kor}-re vonatkozó dolgokat használjunk. Ilyenkor segíthetnek a \textit{cast}ok:
	\begin{lstlisting}
void f(Sikidom *s)
{
	Kor *k = dynamic_cast<Kor*>(s); //korkent szerentenk hasznalni
	if (k == NULL)
	{
		//ha nem volt sikeres a castolas...
	}
}
	\end{lstlisting}
	Ebben a kódrészletben megpróbáljuk \texttt{s}-t átkonvertálni \texttt{Kor} pointer típusra.
	
	A \texttt{dynamic\_cast} futási időben ellenőriz, és ha a cast nem sikeres, nullpointert ad vissza. Azonban nem hatékony, hisz futási időben kell végigjárnia az öröklődési láncot. Ha nem vagyunk biztosak benne, hogy garantáltan lehetséges a castolás, akor \texttt{dynamic\_cast}-ot érdemes használni, ha azonban biztosak vagyunk benne hogy az lehetséges, akkor \texttt{static\_cast} a jobb, mely fordítási időben végzi el ezt, hatékonyabb, azonban kevésbé biztonságos, ugyanis ha a cast sikertelen, akkor nem nullpointert ad vissza, hanem egy nem definiált viselkedés fog bekövetkezni (leggyakrabban elszáll).
	
	Konstruktorokról még beszélnünk kéne: a szemfüleseknek feltűnhetett, hogy a fenti kód le se fordul! (tekintsünk el attól, hogy a \texttt{terulet} metódus hiányzik)
	\begin{lstlisting}
class Sikidom
{
protected:
	int x, y;
public:
	Sikidom(int x, int y) : x(x), y(y) {}
};

class Kor : public Sikidom
{
	double r;
};
	\end{lstlisting}
	Mivel konstruktort nem írtunk \texttt{Kor}-nek, így a fordító generál nekünk egyet, melyben megpróbálja \texttt{Sikidom}-hoz tartozó adattagokat \texttt{Sikidom} paraméter nélküli konstruktorával meghívni. Azonban mivel nincs neki ilyen, fordítási idejű hibát kapunk. Ilyenkor csak egy lehetőségünk van \texttt{Sikidom} módosítása nélkül, írnunk kell \texttt{Kor}-nek egy konstruktort, melynek inicializációs listájában meghívjuk \texttt{Sikidom} egyetlen, két \texttt{int}-et váró konstruktorát.
\begin{lstlisting}
class Sikidom
{
protected:
	int x, y;
public:
	Sikidom(int x, int y) : x(x), y(y) {}
};

class Kor : public Sikidom
{
	double r;
public:
	Kor(int x, int y, int r) : Sikidom(x,y), r(r) {}
};
\end{lstlisting}
	Ezzel \texttt{Sikidom} konstruktorát meg tudtuk hívni. Mi lesz a copy konstruktorokkal? Hasonló helyzetben, ha egy kört másolunk, a síkidom default copy konstrukora fog meghívódni, kivéve, ha az felül van definiálva. Azaz rendre másolásnál ellőször meghívódik a síkidom copy konstruktora, és utána jön a \texttt{Kor} copy konstruktora. Ebben a sorrendben haladnak konstruktorok is, azonban a destruktorok nem: ott a hívási sorrend pont fordítva van, azaz felfelé halad az öröklődési láncon.
	
	\begin{lstlisting}
class A {};
class B : public A {};
class C : public B {};
class D : public C {};
	\end{lstlisting}
	Konstruktorok hívási sorrendje: \texttt{A -> B -> C -> D}
	
	Azonban itt van egy nagy veszélyforrás, hiszen a destruktor is csak akkor hívódik meg jól, ha az virtuális.
	%TODO virtuális destruktorok
	
	Rossz ötlet az STL konténereiből örökölni, hisz azon destruktora nem virtuális. 
	
	%TODO többszörös örkölődés
	%TODO virtuális öröklődés
	%TODO explicit névfeloldás többszörös öröklődésnél
	%TODO polimorfizmusról van szó, de definiálva nincs
	%TODO c++11: override
	%TODO figyelemfelhívás a slicing veszélyeire
	%TODO tisztán virtuális függvények
	%TODO ,,virtuális konstruktorok''
	%TODO privát adattagok használata leszármazotban
	%TODO linkek
\end{document}
