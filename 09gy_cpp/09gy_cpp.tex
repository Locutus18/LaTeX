\documentclass[a4paper,11.5pt]{article}
\usepackage[textwidth=170mm, textheight=230mm, inner=20mm, top=20mm, bottom=30mm]{geometry}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{amsmath, xcolor, amsthm,amssymb,paralist,array, ellipsis, graphicx}
%\usepackage{marvosym}

\usepackage{listings}
\lstset{
	language=C++, 
	basicstyle=\ttfamily, 
	keywordstyle=\color{blue}\ttfamily, 
	stringstyle=\color{red}\ttfamily,
	tabsize = 4
}

\makeatletter
\renewcommand*{\mathellipsis}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\dotsb@}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\@cdots}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\ellipsis@default}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	\ellipsis@after\relax}
\renewcommand*{\ellipsis@centered}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisaftergap
	\ellipsis@after\relax}
\AtBeginDocument{%
	\DeclareRobustCommand*{\dots}{%
		\ifmmode\@xp\mdots@\else\@xp\textellipsis\fi}}
\def\ellipsisgap{.1em}
\def\ellipsisbeforegap{.05em}
\def\ellipsisaftergap{.05em}
\makeatother

\usepackage{hyperref}

\begin{document}
	%%%%%%%%%%%RÖVIDÍTÉSEK%%%%%%%%%%
	\setlength\parindent{0pt}
	\def\s{\hspace{0.2mm}\vphantom{\beta}}
	\def\Z{\mathbb{Z}}
	\def\Q{\mathbb{Q}}
	\def\R{\mathbb{R}}
	\def\C{\mathbb{C}}
	\def\N{\mathbb{N}}
	\def\Ra{\overline{\mathbb{R}}}
	
	\def\sume{\displaystyle\sum_{n=1}^{+\infty}}
	\def\sumn{\displaystyle\sum_{n=0}^{+\infty}}
	
	\def\narrow{\underset{n\rightarrow+\infty}{\longrightarrow}}
	\def\limn{\displaystyle\lim_{n\to +\infty}}
	\def\limx{\displaystyle\lim_{x\to +\infty}}
	
	\theoremstyle{definition}
	\newtheorem{theorem}{Tétel}[subsection] 
	
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definíció} 
	\newtheorem{example}[theorem]{Példa} 
	\newtheorem{task}[theorem]{Feladat} 
	\newtheorem{note}[theorem]{Megjegyzés}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{center}
		{\LARGE\textbf{C++}}
		
		{\Large Gyakorlat jegyzet}
		
		9. óra.
	\end{center}
	A jegyzetet \textsc{Umann} Kristóf készítette \textsc{Brunner} Tibor  előadásán. (\today)
	
	\section{STL}

	Az \textit{STL} a \textit{Standard Template Library} rövidítése.
	\subsection{Funktorok}
	Mielőtt belevetnénk magunkat az STL-ben lévő algoritmusokba és konténerekbe, fontos megismerkednünk a funktorokkal, melyek a rendezéseknél lesznek majd használatosak.
	\medskip
	
	A funktor egy olyan osztály, melynek túl van terhelve a gömbölyű zárójel operátora (tehát kvázi meg lehet hívni).
	
	\smallskip
	Egy egyszerű példa:
	\begin{lstlisting}
struct S
{
	int x;
	int operator()(int y)
	{
		return x + y;
	}
};
int main()
{
	S s1, s2;
	s1.x = 5;
	s2.x = 8;
	std::cout << s1(2) << std::endl; //7
	std::cout << s2(2) << std::endl; //10
}
	\end{lstlisting}
	Itt gyakorlatilag az objektum függvényként funkcionál. A funktorok azért fontosak, mert megadhatók template paraméterként, és így tudjuk elérni, hogy rendezéshez lehessen őket használni.
	\begin{note}
	Miért használunk funktorokat mondjuk függvénypointerek helyett? Világos, hogyha egyedi rendezést akarunk, akkor muszáj ezt az információt valahogy átadni. A funktorok erre alkalmasabbak, példaképp vegyük ehhez egy olyan template függvényt, melynek egyik template paramétere egy olyan funktort vár, melynek \texttt{()} operátora egy paramétert vár és \texttt{bool}-al tér vissza, és feladata az erre igazat adó elem megkeresése. Hogyan tudnánk mi funktorok helyett függvénypointerrel a második páros számot megkeresni vele? Vagy az ötödik 8-al oszthatót? Nos, függvényekkel igencsak nehezen (kb statikus adattagokra kényszerülnénk, vagy egy hasonlóan nem épp elegáns megoldásra), azonban egy funktorban létrehozhatunk egy számlálót, melyet tudunk szépen növelgetni.
	\end{note}
	
	Segíthet a megértésben, ha tekintjük az alábbi példát:
	\begin{lstlisting}
template <class Compr>
bool f(int a, int b, Compr c)
{
	return c(a, b);
}

struct Less
{
	bool operator()(int a, int b) const
	{
		return a < b;
	}
};

int main()
{
	if( f(2,3, Less()) )
		std::cout << "2 kisebb mint 3! ";
	
	int a = 2, b = 2;
	if ( f(a, b, Less()) == false && f(b, a, Less()) == false )
		std::cout << "a es b egyenloek!" << std::endl;
}
	\end{lstlisting}
	Kimenet: \texttt{2 kisebb mint 3! a es b egyenloek!}
	
	Ez a funktor (\texttt{Less}) egy un. \textit{binary predicate}, azaz a gömbölyű zárójel operátora két azonos típusú objektumhoz rendel egy logikai értéket. Figyeljük meg, hogyan adtuk meg a harmadik paramétert: \texttt{Less}-nek meghívtuk a default konstruktorát, de nem adtunk neki változónevet. Itt egy un. névtelen temporális változó jön létre, mely \texttt{f} paramétereinek kiértékelésekor jön létre, majd az \texttt{f} lefutása után meg is semmisül. Figyeljük meg azt is, hogy ebben az esetben érték szerint vettünk át: ez nem csak hatékonyabb, hisz \texttt{Less} mérete minimális (nincs adattagja), de mivel \texttt{Less()} egy jobbérték, csak így, vagy konstans referenciával tudnánk átvenni.
	\smallskip
	
	Jusson eszünkbe, mikor ekvivalens két elem! \quad $a = b \quad \Leftrightarrow \quad \neg(a<b)\, \wedge\, \neg(b<a)$.

	\subsection{Konténerek}
	C++ban az egyetlen tároló alapértelmezetten a tömb. Azonban az meglehetősen kényelmetlen: a tömb egymás mellett lévő memóriacímek összessége, nem tehetjük meg azt, hogy csak úgy hozzáveszünk 1-1 elemet (mi van ha valaki más már írt oda?). Ezért jobban járunk, ha írunk egy egyedi kontért (pl. az általunk létrehozott \texttt{List}), vagy pedig válogatunk az előre megírt STL konténerek között.
	
	Három konténertípust különböztetünk meg:
	\begin{itemize}
		\item Szekvenciális: Olyan sorrendben tárolja az adattagokat, ahogyan betesszük őket. \\Példa: \texttt{std::vector}, \texttt{std::deque,} \texttt{std::list.}
		\item Asszociatív: Az elemek rendezettek a konténerben.\\ Példa: \texttt{std::set}, \texttt{std::map}, \texttt{std::multiset}, \texttt{std::multimap}.
		\item Konténer adapter: Egy meglévő konténert alakítanak át, általában szogorítanak. Példaképp ha vesszük az \texttt{std::deque} konténert, ami egy kétvégű sor, könnyen tudunk belőle egy egyvégű sort csinálni. Ezen a konténerek általában egy másik konténert tárolnak, és annak a funkcióit szigorítják.
		\\Példa: \texttt{std::queue}, \texttt{std::stack}.
	\end{itemize}
	
	\subsubsection{vector}
	A \texttt{<vector>} könyvtárban található, maga a konténer az \texttt{std::vector} névre hallgat. Bár a pontos definíciója értelemszerűen implementációfüggő, vannak olyan tulajdonságok, melyeket elvár a szabvány.
	\smallskip
	
	A \texttt{vector} leggyakrabban dinamikusan lefoglalt tömbben tárolja az adatainkat, viszont a tömb mérete nem növelhető, így ha túl sok elemet akarunk beletenni, a \texttt{vector} lefoglal egy nagyobb memóriaterületet (leggyakrabban kétszer akkorát). Így a \texttt{push\_back}-nek a műveletigénye amortizált konstans: Általában konstans, de ha új memóriaterületet kell lefoglalni és a meglevő elemet átmásolni, akkor lineáris.
	
	\begin{note}
		Számos okból a \texttt{vector} a leggyakoribb választás, ha konténerre van szükségünk. Flexibilitása és gyorsasága kiemelkedő, azonban megvannak a maga gyenge pontjai.
	\end{note}
	
	Gyakorlatilag teljesen lehetetlen minden tagfüggvényt megjegyezni, és nem is érdemes. Bátran forduljunk ide: \url{http://en.cppreference.com/w/cpp/container/vector}.
	\subsubsection{set}
	\url{http://en.cppreference.com/w/cpp/container/set}
%	Példaképp vegyük az előző órán beszélt \texttt{std::set}-et: ennek két template paramétere van, az egyik a tárolandó típus, a másik pedig a rendezés (van még egyéb is, de ezzel most ne foglalkozzunk). Képzeljük el mondjuk így:
	
%	\begin{lstlisting}
%	namespace std
%	{
%	template <class Value, class Compr = std::less<Value> >
%	class set
%	{
%	//...
%	
%	//ossze kell hasonlitani ket elemet: v1 es v2.
%	Compr c;
%	if ( c(v1, v2) )
%	
%	//...
%	};
%	}
%	\end{lstlisting}
%	Figyeljük meg, hogy az \texttt{std::set}-nek van alapértelmezett rendezése is, ez az \texttt{std::less} (ld.: cppreference.com). A \texttt{set} egy olyan funktort fog várni, melyek a gömbölyű zárójel operátora két \texttt{Value} típusú objektumot vár paraméterként, és a visszatérési értéke \texttt{bool.}
	
	\smallskip
	Az \texttt{std::set}-nek nem \texttt{push\_back}, hanem \texttt{insert} függvénye van elem betevésére. Ez a konténer a matematikai halmazra hasonlít, és általában egy kiegyensúlyozott bináris faként van implementálva, a hatékonyság végett.
	\begin{note}
		A szabvány elvárja, hogy az \texttt{insert} műveletigénye logaritmikus legyen.
	\end{note}
	Vegyük észre, hogy a matematikai halmaz alapértelmezetten rendezett, így ez a konténer is az. A rendezés, csakúgy mint a tárolandó típus, template paraméterként van megadva, azonban van alapértelmezett is. Például:
	\begin{lstlisting}
struct Kor
{
	int x, y, r;
};

std::set<Kor> s;
	\end{lstlisting}
	Itt probléma lesz, mert nem adtunk meg template paraméterként egy rendezést, és az alapértelmezett rendezés a \texttt{<} operátort használja, melyet nem írtunk meg a \texttt{Kor}-hoz.
	\begin{note}
		A rendezés megadása template paraméterekkel funktorokkal történik, melyekről később lesz szó.
	\end{note}
	\begin{lstlisting}
struct Kor
{
	int x, y, r;
};
bool operator<(const Kor &lhs, const Kor &rhs)
{
	return lhs.r < lhs.r;
}

std::set<Kor> s;
	\end{lstlisting}
	Példák még a használatra:
\begin{lstlisting}
std::set<Kor> s;

s.insert(Kor(0,0,1));
s.insert(Kor(0,0,2));
s.insert(Kor(1,1,2));
std::cout << s.size() << std::endl;
\end{lstlisting}
	Itt azt várnánk, hogy a halmaz mérete 3 legyen, de 2 lesz mégis. Ez abból adódik, hogy a \texttt{<} operátort úgy alkottuk meg, hogy sugártól függ (azaz az \texttt{r} adattagról), hogy egyik kör nagyobb-e mint a másik. Ez alapján az ekvivalenciát is le tudja vezetni konténer: ha $\neg(a<b)$ és $\neg(b<a)$ akkor $a=b$.
	\subsubsection{list}
	Ez a konténer nagyon hasonló ahhoz, mint amit mi írtunk, csak lehet üres, és kétirányú. 
	\smallskip
	
	Feltűnő lehet, hogy az \texttt{std::vector}-ral szemben ennek a konténernek nincs \texttt{[]} operátora, hiszen ahogy azt korábban is megállapítottuk, mire egy adott elemet elérünk, szépen el kell oda lépegetni egyesével. A szögletes zárójel operátort csak akkor szokás írni, hogy ha nagyon hatékony, lehetőleg konstans az adott elem lekérdezése, de ez a listánál nem teljesül.
	\begin{note}
		Bár elméletben gyorsabb egy láncolt lsitába beszúrni, de általában ez mégsem igaz. Azért, mert az egy dolog, hogy az elemeket egyesével odább kell tolni egy vektorban, azonban mivel abban szekvenciálisan vannak a memóriacímek egymás mellett, és a processzor nem egyesével adja vissza az elemeit, hanem egy nagyobb blokkot mutat belőle, míg a listánál muszáj egyik címről a másikra menni.
	\end{note}
	
	Ha mindenáron szeretnék 3 elemmel előrébb menni kevés gépeléssel, ez lehet megoldás:
\begin{lstlisting}
std::list<int> l;
std::list<int>::iterator i = l.begin();
std::advance(i, 3);
\end{lstlisting}
	Persze, itt listánál egyesével kell előrelépni, de \texttt{std::vector}nál létezik hatékonyabb megoldás is, hogyha simán csak 3-al előrébb ugranánk. Erre majd később látunk egy megoldást.
	\subsubsection{map}
	A map egy kulcs-érték párokat tároló konténer, mely minden kulcshoz egy értéket rendel. Van egy speciális beszúró függvénye is:
\begin{lstlisting}
std::map<std::string, int> m;
m["Hello"] = 42;
m["xyz"] = 8;
m["Hello"] = 9;
\end{lstlisting}
	A \texttt{[]} operátor egy új kulcsot hoz létre, és ahhoz rendel egy új értéket. Az utolsó sornál mivel a \texttt{''Hello''}-t már tartalmazza a map, így annak az értékét felülírja.
	
	\medskip
	\texttt{std::map}-ban az iterálás kicsit trükkösebb.
\begin{lstlisting}
for(std::map<std::string, int>::iterator i = m.begin(); i != m.end(); i++)
{
	std::cout << i->first << " " << i->second;
}
\end{lstlisting}
	Ugyanis \texttt{std::map} párokat tárol, méghozzá egy más alapból megírt struktúrát használ, az \texttt{std::pair}-t, ami kb. így néz ki:
\begin{lstlisting}
template <typename T1, typename T2>
struct pair
{
	T1 first;
	T2 second;
}
\end{lstlisting}
	\subsection{Algoritmusok}
	\subsubsection{Iterátorok}
	Az algoritmusok a iterátorokkal dolgoznak. Ahogy megállapítottuk az előző óra végén, nagyon könnyű egy új függvényt írnunk már meglévő konténerekhez, és egy új konténert is könny írni a meglevő függvényekhez. Jó példát adnak itt az STL konténerek, hisz az összeshez van írva iterátor.
	
	Ha mi szeretnénk új algoritmust írni, például így dolgozhatunk iterátorokkal:
	\begin{lstlisting}
for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i)
{
	std::cout << *i;
}
	\end{lstlisting}
	Azt, hogy az iterátor hogyan oldja meg az iterálást, nem szükséget tudnunk, elég annyi, hogy az első elemtől az utolsóig megy.
	
	\smallskip
	Írjunk példaképp egy ilyen algoritmust:
	\begin{lstlisting}
bool tartalmaz(const std::set<int> &s, int x)
{
	for(std::set<int>::iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
			return true;
	}
	return false;
}
	\end{lstlisting}
	
	Ez egy nagyon nem általános függvény, mert csak \texttt{std::set}-et fogadunk el, és csak akkor, ha ezek \texttt{int}éel vannak példányosítva. Csináljunk ebből egy egyel általánosabbat:
\begin{lstlisting}
template <typename T>
bool tartalmaz(const std::set<T> &s, int x)
{
	for(std::set<T>::iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	Ez persze nem biztos hogy működni fog, ugyanis senki nem garantálja, hogy a \texttt{T} típusnak van van \texttt{==} operátora. (és ez a kód amúgy is még vérzik pár sebből)
	
	\medskip
	Mellékesen, milyen jó lenne, ha nem csak \texttt{std::set}-re működne ez, hanem bármilyen itárorral rendelkező konténerre!
\begin{lstlisting}
template <typename It, typename T>
It find(It &first, It &last, const T &a)
{
	while (first != last)
	{
		if (*first == a)
			return first;
		++first;
	}
	return last;
}
\end{lstlisting}
	Figyeljük meg, hogy a visszatérési érték is megváltozott: keresünk egy \texttt{a} értékű elemű, és ha megtaláljuk, egy arra mutató iterátort adunk vissza. Ha nem találunk, akkor az utolsó utáni elemet adjuk vissza. Ez már egy egész jó kereső algoritmust.
	
	\medskip
	Javítsuk ki a fenti függvényt, ahonnét hiányzik a \texttt{typename}.
\begin{lstlisting}
template <typename T>
bool tartalmaz(const std::set<T> &s, int x)
{
	for(typename std::set<T>::iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	
	\medskip
	Kérdés, tudunk-e ilyet tenni?:
\begin{lstlisting}
std::set<int>>::iterator i = s.begin();
*i = 42;
\end{lstlisting}
	Már a kérdésból is látszdik, hgoy ez nem lehetséges, hisz a \texttt{std::set} itetátora igazából egy konstans iterátort. EZ azért van, mely lévén egy bináris faként van áltlaában implementálva a \texttt{std::set}, a fa rendezett szerkezetét fel tudnánk rúgni.
	
	\smallskip
	Mit tegyünk akkor, ha konstansot veszek át? A fenti példában is ez van, a set-et konstansként vettük át. Így, hasonlóan az általunk írt láncolt listához, egy konstans iterátorral kell végigmennünk.
\begin{lstlisting}
template <typename T>
bool tartalmaz(const std::set<T> &s, int x)
{
	for(typename std::set<T>::const_iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	
	\medskip
	Közel az összes STL algoritmus iterátor párokat vár, legyenek pl. \texttt{first} és \texttt{last}. Ilyenkor az első elemtől az utolsóig megy, így: \texttt{[first, last)}. Azaz a \texttt{last} iterátorhoz már nem ér! (Erre könnyű is magyarázatot találni, miért: a mi általunk írt lista \texttt{end()} metódusa egy olyan iterátort ad vissza, mely gyakorlatilag egy nullpointer. Ha ezt megkapnánk dereferálni, nem definiált viselkedést kapnánk, így általában az end() nem az utolsó elemet, hanem az utolsó utáni elemet adja vissza)
	
	\subsubsection{find}
	Értelemszerűen, nem kell megírni a find függvényt, hisz ez alapból benne van az STL-ben. Ehhez a függvényhez az \texttt{<algorithm>} könyvtár beillezstésével férhetünk hozzá. 
	
	\medskip
	Azért se épp jó a mi algoritmusunk, mert példaképp a halmaz rendezett, így ott logaritmikus keresést is használhatnánk! Ezért szokás az ilyen speciális konténereknek egyedi find függvényt írni, ami az \texttt{std::set} esetében egy tagfüggvény. 
\begin{lstlisting}
set<int>::iterator i = s.find(42);
if (i == s.end())
	std::cout << "nincs" << std::endl;
\end{lstlisting}
	Azonban megállapítandó, hogy az \texttt{std::set} nem \texttt{==} operátorral ellenőrzi az ekvivalenciát, hanem a template paraméterként kapott rendezéssel! (ami alapértelemzetten a \texttt{<} operátortól függ).
\begin{lstlisting}
struct Kor
{
	int x, y, r;
};
bool operator<(const Kor &lhs, const Kor &rhs)
{
	return lhs.r < lhs.r;
}
bool operator==(const Kor &lhs, const Kor &rhs)
{
	return lhs.r == rhs.r && lhs.x == rhs.y && lhs.y == rhs.y;
}
\end{lstlisting}
	Itt az a veszély, hogy ha az STL-es find-al szemben a sajátunkat használjuk, más lehet a végeredmény, hisz a \texttt{Kor}-t ők máshogy hasonlítják össze.
	
\end{document}
