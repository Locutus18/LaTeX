\documentclass[a4paper,11.5pt]{article}
\usepackage[textwidth=170mm, textheight=230mm, inner=20mm, top=20mm, bottom=30mm]{geometry}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{amsmath, xcolor, amsthm,amssymb,paralist,array, ellipsis, graphicx, multirow}
%\usepackage{marvosym}

\usepackage{listings}
\lstset{
	language=C++, 
	basicstyle=\ttfamily, 
	keywordstyle=\color{blue}\ttfamily, 
	stringstyle=\color{red}\ttfamily,
	tabsize = 4
}

\makeatletter
\renewcommand*{\mathellipsis}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\dotsb@}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\@cdots}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\ellipsis@default}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	\ellipsis@after\relax}
\renewcommand*{\ellipsis@centered}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisaftergap
	\ellipsis@after\relax}
\AtBeginDocument{%
	\DeclareRobustCommand*{\dots}{%
		\ifmmode\@xp\mdots@\else\@xp\textellipsis\fi}}
\def\ellipsisgap{.1em}
\def\ellipsisbeforegap{.05em}
\def\ellipsisaftergap{.05em}
\makeatother

\usepackage{hyperref}
\hypersetup{
	colorlinks = true	
}

\begin{document}
	%%%%%%%%%%%RÖVIDÍTÉSEK%%%%%%%%%%
	\setlength\parindent{0pt}
	\def\s{\hspace{0.2mm}\vphantom{\beta}}
	\def\Z{\mathbb{Z}}
	\def\Q{\mathbb{Q}}
	\def\R{\mathbb{R}}
	\def\C{\mathbb{C}}
	\def\N{\mathbb{N}}
	\def\Ra{\overline{\mathbb{R}}}
	
	\def\sume{\displaystyle\sum_{n=1}^{+\infty}}
	\def\sumn{\displaystyle\sum_{n=0}^{+\infty}}
	
	\def\narrow{\underset{n\rightarrow+\infty}{\longrightarrow}}
	\def\limn{\displaystyle\lim_{n\to +\infty}}
	\def\limx{\displaystyle\lim_{x\to +\infty}}
	
	\theoremstyle{definition}
	\newtheorem{theorem}{Tétel}[subsection] 
	
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definíció} 
	\newtheorem{example}[theorem]{Példa} 
	\newtheorem{task}[theorem]{Feladat} 
	\newtheorem{note}[theorem]{Megjegyzés}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{center}
		{\LARGE\textbf{C++}}
		
		{\Large Gyakorlat jegyzet}
		
		10. óra.
	\end{center}
	A jegyzetet \textsc{Umann} Kristóf készítette \textsc{Brunner} Tibor és \textsc{Horváth} Gábor előadásán. (\today)
	\section{Iterátor típusok}
	Korábban már elhangzott, hogy az általunk implementált \texttt{List}-hez tartozó \texttt{Iterator} és \texttt{ConstIterator} un. forward iterátorok. A forward iterator egy iterátor típus -- ebből több is van, és elengedhetetlenek az STL algoritmusok megértéséhez. 4 iterátor típust különböztetünk meg: input iterator, forward iterator, bidirectional iterator és random access iterator.
	\begin{itemize}
		\item Az \textbf{input iterator} típusokon legalább egyszer végig lehet menni egy irányba, továbbá rendelkeznek \texttt{++}, \texttt{*}, \texttt{==} és \texttt{!=} operátorral.
		\item A \textbf{forward iterator} típusokon többször is végig lehet menni, de csak egy irányba. Továbbá rendelkeznek \texttt{++}, \texttt{*}, \texttt{==} és \texttt{!=} operátorral.
		\item A \textbf{bidirectional iterator} típusokon többször is végig lehet menni, mindkét irányba. Továbbá rendelkeznek \texttt{++}, \texttt{$--$}, \texttt{*}, \texttt{==} és \texttt{!=} operátorral.
		\item A \textbf{random access iterator} típusokon többször is végig lehet menni, mindkét irányba, ezen felül a két iterátor között bármelyik elemre azonnal lehet hivatkozni. Továbbá rendelkeznek \texttt{++}, \texttt{
		$--$}, \texttt{*}, \texttt{==}, \texttt{!=}, \texttt{$-$} (két iterátor távolságát adja meg), összeadás \texttt{int}-el (paraméterként kapott mennyiségű elemmel előrelépés), kivonás \texttt{int}-el (hátralépés) operátorral/függvénnyel.
	\end{itemize}
	E listán látható, hogy pl. egy random access iterator sokkal flexibilisebb, és gyorsabb is, hisz bármikor bármelyik elemhez hozzáférhetünk, míg a mi listánk forward iteratora sokkal limitáltabb.
	
	\smallskip
	Az STL konténerek iterátorai is különböző iterator kategóriákban vannak:
	\begin{center}
		\begin{tabular}{|l|l|}
			\hline
			STL konténer&Iterator típus\\
			\hline
			\hline
			\texttt{std::vector} & \multirow{2}{*}{\texttt{random access iterator}}\\
			\texttt{std::deque} &\\
			\hline
			\texttt{std::list} & \multirow{5}{*}{\texttt{bidirectional iterator}}\\
			\texttt{std::set} & \\
			\texttt{std::multiset} & \\
			\texttt{std::map} & \\
			\texttt{std::multimap} & \\
			\hline
		\end{tabular}
	\end{center}
	Világos, hogy egy flexibilisebb iterátorral több mindent meg tudunk tenni, vagy ugyanazt a funkciót hatékonyabban is meg tudjuk valósítani. Emiatt minden STL algoritmusnak (mint pl. az \texttt{std::find}) tudnia kell a template paraméterként kapott iterátor kategóriáját.
	\medskip
	
	Egy iterátornak úgy tudjuk a legegyszerűbben megadni a típusát, ha származunk az \texttt{std::iterator} típusból.
	
	Link: \url{http://en.cppreference.com/w/cpp/iterator/iterator}
	
	Látható hogy ennek osztálynak két kötelező template paramétere van, egy iterátor típus tag, és dereferáló operátor visszatérési értéke.
	
	\begin{lstlisting}
template <class T>
class Iterator : public std::iterator<std::forward_iterator_tag, T>
{
	//..
};

template <class T>
class ConstIterator : public std::iterator<std::forward_iterator_tag, T>
{
	//..
};
	\end{lstlisting}
	Így már fogjuk tudnuk majd használni az \texttt{STL} algoritmusokat is a konténereinken. 
	%TODO
%	\begin{note}
%		Ez egy baromi nagy dolog: létrehoztunk egy új adatszerkezetet, és ez tök jól együttműködik az eddigi algoritmusokkal.
%		
%		Azaz még viszonylag egyszerűen egy új függvényt is létre tudunk hozni, ami minden adatszerkezettel működni fog! C++ban az algoritmusok nem a konténereken működnek: lévén úgy szokás konténereket létrehozni, hogy írunk hozzá iterátort is, így elegendő egy algirtmusnak azt tudnia, hogy hogyan kell használni azt az iterátort. Emiatt várja el egy STL algoritmus, hogy közöüljük, milyen típusú iterátorunk van. Igaz, a konténereinkkel többet kell dolgoznunk, mert ezt az iterátort egyszer meg kell írni, de hosszú távon még így is rengeteg munkát tudunk megspórolni.
%	\end{note}
	
	\section{STL algoritmusok}
	\subsection{Bevezető az algortmusokhoz}
	Az STL algoritmusok az \texttt{<algorithm>} könyvtárban találhatóak, és számos jól ismert és fontos függvényt foglalnak magukba, mint pl. adott tulajdonságű elem keresése, partícionálás, szimmetrikus differencia meghatározása, stb.
	\medskip
	
	Az STL algoritmusok alap gondolatmenetét jól demonstrálja az alábbi példa (most még tekintsünk el az iterátor típusoktól): Írjunk egy függvény mely a második adott értékű elemet adja vissza!
	\begin{lstlisting}
#include <vector>
#include <iostream>

template <class It, class Val>
It findSecond(It begin, It end, const Val &v)
{
	while(begin != end && *begin != v)
	{
		++begin;
	}
	if (begin == end)
		return end;
	++begin;
	while(begin != end && *begin != v)
	{
		++begin;
	}
	return begin;
}

int main()
{
	std::vector<int> v;
	for (int i = 0; i<10; i++)
		v.push_back(i);
	v.push_back(5);
	std::vector<int>::iterator it = findSecond(v.begin(), v.end(), 5);
	if (it != v.end())
		std::cout << *it << std::endl; // 5
}
	\end{lstlisting}
	
	Az algoritmusok iterátorokkal dolgoznak, azonban az, hogy minek az iterátorát használják, egyáltalán nem fontos tudniuk: elegendő annyi, hogy rendelkeznek azokkal az operátorokkal, melyeket fent felsoroltunk. Így például a mi listánk iterátorát ugyanúgy megadhatnánk a fenti függvények, mint egy \texttt{std::vector<int>}-ét.
	
	%TODO brunner tibis rész
	
	\medskip
	Azonban hogyan lehet megállapítani az iterator típusát? Emlékezzünk vissz arra, hogy a \texttt{List}-ét hogyan jelöltük meg: az öröklődés következtében az osztályunk kapott pár typedef-et, melyek közül az egyik az \texttt{iterator\_category}.
	\begin{lstlisting}
template<typename BDIT> 
void algorithm(BDIT, BDIT, std::bidirectional_iterator_tag) 
{
	std::cout << "Slow" << std::endl;
}

template<typename RAIT>
void algorithm(RAIT, RAIT, std::random_access_iterator_tag) 
{
	std::cout << "Fast" << std::endl;
}

template<typename IT> 
void algorithm(IT begin, IT end) 
{
	typedef typename std::iterator_traits<IT>::iterator_category cat;
	algorithm(begin, end, cat());
}
int main() 
{
	std::vector<int> v;
	std::list<int> l;
	algorithm(v.begin(), v.end()); // Fast
	algorithm(l.begin(), l.end()); //Slow
}  
	\end{lstlisting}
	Mit tegyünk akCircle, ha konstansot veszek át? A fenti példában is ez van, a set-et konstansként vettük át. Így, hasonlóan az általunk írt láncolt listához, egy konstans iterátorral kell végigmennünk.
\begin{lstlisting}
template <typename T>
bool contains(const std::set<T> &s, int x)
{
	for(typename std::set<T>::const_iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	
	\medskip
	Közel az összes STL algoritmus iterátor párokat vár, legyenek pl. \texttt{first} és \texttt{last}. IlyenCircle az első elemtől az utolsóig megy, így: \texttt{[first, last)}. Azaz a \texttt{last} iterátorhoz már nem ér! (Erre könnyű is magyarázatot találni, miért: a mi általunk írt lista \texttt{end()} metódusa egy olyan iterátort ad vissza, mely gyaCirclelatilag egy nullpointer. Ha ezt megkapnánk dereferálni, nem definiált viselkedést kapnánk, így általában az end() nem az utolsó elemet, hanem az utolsó utáni elemet adja vissza)
	
	\subsubsection{find}
	Értelemszerűen, nem kell megírni a find függvényt, hisz ez alapból benne van az STL-ben. Ehhez a függvényhez az \texttt{<algorithm>} könyvtár beillezstésével férhetünk hozzá. 
	
	\medskip
	Azért se épp jó a mi algoritmusunk, mert példaképp a halmaz rendezett, így ott logaritmikus keresést is használhatnánk! Ezért szokás az ilyen speciális konténereknek egyedi find függvényt írni, ami az \texttt{std::set} esetében egy tagfüggvény. 
\begin{lstlisting}
set<int>::iterator i = s.find(42);
if (i == s.end())
	std::cout << "nincs" << std::endl;
\end{lstlisting}
	Azonban megállapítandó, hogy az \texttt{std::set} nem \texttt{==} operátorral ellenőrzi az ekvivalenciát, hanem a template paraméterként kapott rendezéssel! (ami alapértelemzetten a \texttt{<} operátortól függ).
\begin{lstlisting}
struct Circle
{
	int x, y, r;
};
bool operator<(const Circle &lhs, const Circle &rhs)
{
	return lhs.r < lhs.r;
}
bool operator==(const Circle &lhs, const Circle &rhs)
{
	return lhs.r == rhs.r && lhs.x == rhs.y && lhs.y == rhs.y;
}
\end{lstlisting}
	Itt az a veszély, hogy ha az STL-es find-al szemben a sajátunkat használjuk, más lehet a végeredmény, hisz a \texttt{Circle}-t ők máshogy hasonlítják össze.
	%TODO xazaxos rész
	\subsection{STL felépítése}
	Látogassunk el a \url{http://en.cppreference.com/w/} oldalra, és picikét barátkozzunk vele. Itt láthatjuk az összes STL konténert, de sok fontos információhoz is hozzájuthatunk, pl. az \texttt{std::string}-el kapcsolatban is: példaképp az \texttt{std::string} csak egy typename!
	
	Mivel teljesen irreális minden STL algoritmusról részletesen beszélni, így ajánlatos ezeket is nézni: \url{http://en.cppreference.com/w/cpp/algorithm}.
	
	Érdemes megbarátkozni az STL-el: lévén vizsgán lehet használni mindent ami a standard könyvtárban benne van, könnyen megspórolhatjuk a gondolkodást a megfelelő STL algoritmus hívásával.
	
	\medskip
	Rendezzük egy \texttt{vector} elemeit!
	\begin{lstlisting}
std::vector<int> v {6,3,7,4,1,3};
std::set<int> s {6,3,7,4,1,3};
std::set<int> s1(v.begin(), v.end());
v.assign(s1.begin(), s1.end());
for(int i : v)
{
	std::cout << i << ' '; // 1 3 4 6 7 
}
	\end{lstlisting}
	\begin{note}
		Az fenti inicializálások a c++11-es újítás részei, sok magyarázatra gondolom nem szorulnak.
		
		A fenti ciklus szokatlan lehet, ez is egy c++11es újítás, un. \textit{range-based for loop}. A fenti kód ezzel ekvivalens:
		\begin{lstlisting}
int i;
for(std::vector<int>::iterator it = v.begin(); it != v.end(); it++)
{
	i = *it;
	std::cout << i << ' ';
}
		\end{lstlisting}
		Számunkra legyen elég most annyi, hogy az így írt ciklusok akkor működnek, ha a jobb oldalon álló objektum (most \texttt{v}) rendelkezik \texttt{begin()} és \texttt{end()} tagfüggvényekkel, vagy pedig az objektum egy tömb. Ez nem a teljes lista, de most legyen egyenlőre ennyi elég.
	\end{note}
	Most kihasználtuk, hogy az \texttt{std::set} alapértelmezetten rendezett: átpakoljuk abba, majd vissza. No persze, ez minden, csak nem hatékony. Továbbá feltűnhet, hogy az egyik 3-as kiesett: az \texttt{std::set} kiszűrte az egyiket, mert ekvivalens elemet nem tárol. Ennél sokkal hatékonyabb, ha egy STL algoritmussal dolgozunk:
	\begin{lstlisting}
std::vector<int> v {6,3,7,4,1,3};
std::sort(v.begin(), v.end());
for(int i : v)
{
	std::cout << i << ' '; // 1 3 3 4 6 7 
}
	\end{lstlisting}
	Fontosabb algoritmusok:
	\begin{compactitem}
		\item find
		\item search
		\item sort
		\item reverse
		\item rotate
		\item unique
		\item remove
		\item stb...
	\end{compactitem}
	Beszéljünk is ez utóbbiról!
	
	\url{http://en.cppreference.com/w/cpp/algorithm/remove}
	\begin{lstlisting}
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
	std::vector<int> v{1,2,3,3,4,5,6};
	std::cout << v.size() << std::endl;
	std::remove(v.begin(), v.end(), 3);
	std::cout << v.size() << std::endl;
}
	\end{lstlisting}
	Legnagyobb meglepetésünkre, ez semmit se fog törölni: az \texttt{std::remove} átrendezi a konténert, úgy hogy a konténer elején legyenek a nem törlendő elemeket, és utána a törlendőek, és az első törlendő elemre visszaad egy iterátort. Ennek segítségével tudjuk, hogy ettől az iterátortól a \textit{past-the-end iterator}-ig minden törlendő.
	\begin{lstlisting}
std::vector<int> v{1,2,3,3,4,5,6};
std::cout << v.size() << std::endl;
auto it = std::remove(v.begin(), v.end(), 3);
v.erase(it, v.end());
std::cout << v.size() << std::endl;
	\end{lstlisting}
	\begin{note}
		Ebben a kódban van pár c++11-es újítás is: az \texttt{auto} kulcsszó megadható konkrét típus helyett. Ilyenkor az egyenlőségjel bal oldalán lévő objektum típusára helyettesítődik a kulcsszó. Példaképp, fent a fordító meg tudja határozni, hogy az \texttt{std::remove}-nak a visszatérési értéke itt \texttt{std::vector<int>::iterator} lesz, így a kód azzal ekvivalens, mintha ezt írtuk volna:
		
		{\centering\texttt{std::vector<int>::iterator it = std::remove(v.begin(), v.end(), 3);} \par}
		
		Bár az \texttt{auto} kulcsszót sokáig lehetne még boncolgatni, legyen annyi elég egyenlőre, hogy a template paraméter dedukciós szabályok szerint működik: azaz a const/volatile tulajdonságok \textit{(c/v qualifiers)} elvesznek közben. (c++11et nem szükséges tudni a vizsgához)
	\end{note}
	
	\medskip
	Megjegyzendő, hogy nem minden algoritmus működik minden iterátor típussal, és vannak egyes algoritmusokank speciális előfeltétele: például az \texttt{std::unique} egy rendezett konténert vár. Megjegyzendő még, hogy két különböző rendező algoritmusunk is van: \texttt{std::sort} és \texttt{std::stable\_sort}. AZ utóbbi garantálja, hogy az ekvivalens elemek relatív sorrendje ne vltozzon (pl. korábbi példában az \texttt{ADA} és a \texttt{C++}, melyek ekvivalensek, de nem egyenlőek).
	
	Fontos az is, hogy ezek az algoritmusok általában nagyon hatékonyak, így gyakran nem is érdemes sajt magunktól megírni.
	
	\medskip
	Fent kiírtam hogy \texttt{std::remove}, de ebből a namespace-t elhagyhatom.
	\begin{lstlisting}
//...
auto it = remove(v.begin(), v.end(), 3);
//...
	\end{lstlisting}
	Itt a fordító a függvény paraméterekből ki tudja találni (\textit{Argument Dependent Lookup, ADL}), hogy milyen névtérből van az algoritmus. Mivel a \texttt{vector} ugyanúgy az \texttt{std} névtérből származik, és azt adtunk meg paraméternek, tudni fogja a fordító, hogy a \texttt{remove}-ot is abban a névtérben kell keresni.
	
	\bigskip
	
	Vegyünk egy konténert, és jelöljünk meg benne bár elemet, melyektől azt szeretnénk, hogy legyenek egymás mellett, de minden más elem sorrendje ne változzon.
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&*&&*&*&&*\\
			\hline
		\end{tabular}
		
		$\Downarrow$
		
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&*&*&*&*&&\\
			\hline
		\end{tabular}
	\end{center}
	Próbáljuk a csillaggal jelölt elemet egymás mellé tenni: ezt megtehetjük pl. két \texttt{stable\_partition}-nel, mert az ekvivalens elemek sorrendjét nem változtatják. 
	
	Most csináljuk azt, hogy a kijelölt elemek a konténer végén legyenek, de a többi elem sorrendje ne változzon! Itt használhatjuk az előbbi algoritmusok után az \texttt{std::rotate}-et.
	\begin{center}
		
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&*&*&*&*&&\\
			\hline
		\end{tabular}
		
		$\Downarrow$
		
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&&&*&*&*&*\\
			\hline
		\end{tabular}
	\end{center}
	A legtöbb algoritmusnál, mely visszatér egy iterátorral, úgy jelzik, hogy az adott elemet nem találtak meg (stb), hogy egy \texttt{past-the-end} iterátort adnak vissza.
	%TODO jobb struktúrálás.
	\begin{center}
		\textit{,,Általában az emberek nem szeretik, hogyha kicsesznek velük, és ha kicseszel a kollégáiddal, morcosak lesznek''}
		
		/Horváth Gábor/
	\end{center}
\end{document}
