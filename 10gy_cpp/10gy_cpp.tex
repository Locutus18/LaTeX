\documentclass[a4paper,11.5pt]{article}
\usepackage[textwidth=170mm, textheight=230mm, inner=20mm, top=20mm, bottom=30mm]{geometry}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{amsmath, xcolor, amsthm,amssymb,paralist,array, ellipsis, graphicx}
%\usepackage{marvosym}

\usepackage{listings}
\lstset{
	language=C++, 
	basicstyle=\ttfamily, 
	keywordstyle=\color{blue}\ttfamily, 
	stringstyle=\color{red}\ttfamily,
	tabsize = 4
}

\makeatletter
\renewcommand*{\mathellipsis}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisgap%
		{\ldotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\dotsb@}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\@cdots}{%
	\mathinner{%
		\kern\ellipsisbeforegap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisgap%
		{\cdotp}\kern\ellipsisaftergap%
	}%
}
\renewcommand*{\ellipsis@default}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	\ellipsis@after\relax}
\renewcommand*{\ellipsis@centered}{%
	\ellipsis@before
	\kern\ellipsisbeforegap
	.\kern\ellipsisgap
	.\kern\ellipsisgap
	.\kern\ellipsisaftergap
	\ellipsis@after\relax}
\AtBeginDocument{%
	\DeclareRobustCommand*{\dots}{%
		\ifmmode\@xp\mdots@\else\@xp\textellipsis\fi}}
\def\ellipsisgap{.1em}
\def\ellipsisbeforegap{.05em}
\def\ellipsisaftergap{.05em}
\makeatother

\usepackage{hyperref}
\hypersetup{
	colorlinks = true	
}

\begin{document}
	%%%%%%%%%%%RÖVIDÍTÉSEK%%%%%%%%%%
	\setlength\parindent{0pt}
	\def\s{\hspace{0.2mm}\vphantom{\beta}}
	\def\Z{\mathbb{Z}}
	\def\Q{\mathbb{Q}}
	\def\R{\mathbb{R}}
	\def\C{\mathbb{C}}
	\def\N{\mathbb{N}}
	\def\Ra{\overline{\mathbb{R}}}
	
	\def\sume{\displaystyle\sum_{n=1}^{+\infty}}
	\def\sumn{\displaystyle\sum_{n=0}^{+\infty}}
	
	\def\narrow{\underset{n\rightarrow+\infty}{\longrightarrow}}
	\def\limn{\displaystyle\lim_{n\to +\infty}}
	\def\limx{\displaystyle\lim_{x\to +\infty}}
	
	\theoremstyle{definition}
	\newtheorem{theorem}{Tétel}[subsection] 
	
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definíció} 
	\newtheorem{example}[theorem]{Példa} 
	\newtheorem{task}[theorem]{Feladat} 
	\newtheorem{note}[theorem]{Megjegyzés}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{center}
		{\LARGE\textbf{C++}}
		
		{\Large Gyakorlat jegyzet}
		
		10. óra.
	\end{center}
	A jegyzetet \textsc{Umann} Kristóf készítette \textsc{Brunner} Tibor és \textsc{Horváth} Gábor előadásán. (\today)
	\section{STL algoritmusok}\section{Iterátor típusok}
	No, próbáljuk meg alkalmazni a listánkat! Példaképp eresszük rá az alapból megírt algoritmusok egyikét:
	\begin{lstlisting}
	#include <algorithm>
	#include <iostream>
	#include "list.hpp"
	
	int main()
	{
	List<int> head(5);
	head.add(8);
	head.add(10);
	head.add(8);
	List<int>::Iteratorit = std::find(head.begin(), head.end(), 8);
	}
	\end{lstlisting}
	Azonban ez a kód nem fog lefordulni.
	
	\url{http://en.cppreference.com/w/cpp/iterator}
	
	Mivel netet mindig lehet használni, célszerű lehet a cppreference-t böngészni. Ezen a linken láthatjuk, hogy több iterátor típus is létezik.
	
	Láthatjuk, hogy több iterátor kategória is létezik, egyesek többet tudnak mint mások: erre a legfényesebb példa a listánk forward iterátora és egy tömb random access iterátora. A mi listánkon kizárólag az első elemtől az utolsóig tudunk sorban menni, míg egy tömb bármelyik elemére bármikor hivatkozhatunk. Világos, hogy egy flexibilisebb iterátorral több mindent meg tudunk tenni, vagy ugyanazt a funkciót hatékonyabban is meg tudjuk valósítani. Emiatt minden STL algoritmusnak (mint pl. az \texttt{std::find}) tudnia kell a template paraméterként kapott iterátor kategóriáját.
	
	Egy iterátornak úgy tudjuk a legegyszerűbben megadni a típusát, ha származunk az \texttt{std::iterator} típusból.
	
	\url{http://en.cppreference.com/w/cpp/iterator/iterator}
	
	\begin{lstlisting}
	class Iterator : public std::iterator<std::forward_iterator_tag, T>
	{
	//..
	};
	class ConstIterator : public std::iterator<std::forward_iterator_tag, T>
	{
	//..
	};
	\end{lstlisting}
	Ezzel a módosítással már lefordul a kódunk! Így már tudjuk majd használni az \texttt{STL} algoritmusokat is a konténereinken. Ez egy baromi nagy dolog: létrehoztunk egy új adatszerkezetet, és ez tök jól együttműködik az eddigi algoritmusokkal.
	
	\medskip
	Írjunk egy függvény mely a második adott értékű elemet adja vissza.
	\begin{lstlisting}
	template <class It, class Val>
	It find2(It begin, It end, const Val &v)
	{
	It first = std::find(begin, end, v);
	if(first == end)
	return end;
	++first;
	return std::find(first, end, v);
	}
	\end{lstlisting}
	Azaz még viszonylag egyszerűen egy új függvényt is létre tudunk hozni, ami minden adatszerkezettel működni fog! C++ban az algoritmusok nem a konténereken működnek: lévén úgy szokás konténereket létrehozni, hogy írunk hozzá iterátort is, így elegendő egy algirtmusnak azt tudnia, hogy hogyan kell használni azt az iterátort. Emiatt várja el egy STL algoritmus, hogy közöüljük, milyen típusú iterátorunk van. Igaz, a konténereinkkel többet kell dolgoznunk, mert ezt az iterátort egyszer meg kell írni, de hosszú távon még így is rengeteg munkát tudunk megspórolni.
	
	
	Az algoritmusok a iterátorokkal dolgoznak. Ahogy megállapítottuk az előző óra végén, nagyon könnyű egy új függvényt írnunk már meglévő konténerekhez, és egy új konténert is könny írni a meglevő függvényekhez. Jó példát adnak itt az STL konténerek, hisz az összeshez van írva iterátor.
	
	Ha mi szeretnénk új algoritmust írni, például így dolgozhatunk iterátorokkal:
	\begin{lstlisting}
for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i)
{
	std::cout << *i;
}
	\end{lstlisting}
	Azt, hogy az iterátor hogyan oldja meg az iterálást, nem szükséget tudnunk, elég annyi, hogy az első elemtől az utolsóig megy.
	
	\smallskip
	Írjunk példaképp egy ilyen algoritmust:
	\begin{lstlisting}
bool tartalmaz(const std::set<int> &s, int x)
{
	for(std::set<int>::iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
			return true;
	}
	return false;
}
	\end{lstlisting}
	
	Ez egy nagyon nem általános függvény, mert csak \texttt{std::set}-et fogadunk el, és csak akCircle, ha ezek \texttt{int}éel vannak példányosítva. Csináljunk ebből egy egyel általánosabbat:
\begin{lstlisting}
template <typename T>
bool tartalmaz(const std::set<T> &s, int x)
{
	for(std::set<T>::iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	Ez persze nem biztos hogy működni fog, ugyanis senki nem garantálja, hogy a \texttt{T} típusnak van van \texttt{==} operátora. (és ez a kód amúgy is még vérzik pár sebből)
	
	\medskip
	Mellékesen, milyen jó lenne, ha nem csak \texttt{std::set}-re működne ez, hanem bármilyen itárorral rendelkező konténerre!
\begin{lstlisting}
template <typename It, typename T>
It find(It &first, It &last, const T &a)
{
	while (first != last)
	{
		if (*first == a)
			return first;
		++first;
	}
	return last;
}
\end{lstlisting}
	Figyeljük meg, hogy a visszatérési érték is megváltozott: keresünk egy \texttt{a} értékű elemű, és ha megtaláljuk, egy arra mutató iterátort adunk vissza. Ha nem találunk, akCircle az utolsó utáni elemet adjuk vissza. Ez már egy egész jó kereső algoritmust.
	
	\medskip
	Javítsuk ki a fenti függvényt, ahonnét hiányzik a \texttt{typename}.
\begin{lstlisting}
template <typename T>
bool tartalmaz(const std::set<T> &s, int x)
{
	for(typename std::set<T>::iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	
	\medskip
	Kérdés, tudunk-e ilyet tenni?:
\begin{lstlisting}
std::set<int>>::iterator i = s.begin();
*i = 42;
\end{lstlisting}
	Már a kérdésból is látszdik, hgoy ez nem lehetséges, hisz a \texttt{std::set} itetátora igazából egy konstans iterátort. EZ azért van, mely lévén egy bináris faként van áltlaában implementálva a \texttt{std::set}, a fa rendezett szerkezetét fel tudnánk rúgni.
	
	\smallskip
	Mit tegyünk akCircle, ha konstansot veszek át? A fenti példában is ez van, a set-et konstansként vettük át. Így, hasonlóan az általunk írt láncolt listához, egy konstans iterátorral kell végigmennünk.
\begin{lstlisting}
template <typename T>
bool tartalmaz(const std::set<T> &s, int x)
{
	for(typename std::set<T>::const_iterator i = s.begin(); i != s.end(); ++i)
	{
		if(*i == x)
		return true;
	}
	return false;
}
\end{lstlisting}
	
	\medskip
	Közel az összes STL algoritmus iterátor párokat vár, legyenek pl. \texttt{first} és \texttt{last}. IlyenCircle az első elemtől az utolsóig megy, így: \texttt{[first, last)}. Azaz a \texttt{last} iterátorhoz már nem ér! (Erre könnyű is magyarázatot találni, miért: a mi általunk írt lista \texttt{end()} metódusa egy olyan iterátort ad vissza, mely gyaCirclelatilag egy nullpointer. Ha ezt megkapnánk dereferálni, nem definiált viselkedést kapnánk, így általában az end() nem az utolsó elemet, hanem az utolsó utáni elemet adja vissza)
	
	\subsubsection{find}
	Értelemszerűen, nem kell megírni a find függvényt, hisz ez alapból benne van az STL-ben. Ehhez a függvényhez az \texttt{<algorithm>} könyvtár beillezstésével férhetünk hozzá. 
	
	\medskip
	Azért se épp jó a mi algoritmusunk, mert példaképp a halmaz rendezett, így ott logaritmikus keresést is használhatnánk! Ezért szokás az ilyen speciális konténereknek egyedi find függvényt írni, ami az \texttt{std::set} esetében egy tagfüggvény. 
\begin{lstlisting}
set<int>::iterator i = s.find(42);
if (i == s.end())
	std::cout << "nincs" << std::endl;
\end{lstlisting}
	Azonban megállapítandó, hogy az \texttt{std::set} nem \texttt{==} operátorral ellenőrzi az ekvivalenciát, hanem a template paraméterként kapott rendezéssel! (ami alapértelemzetten a \texttt{<} operátortól függ).
\begin{lstlisting}
struct Circle
{
	int x, y, r;
};
bool operator<(const Circle &lhs, const Circle &rhs)
{
	return lhs.r < lhs.r;
}
bool operator==(const Circle &lhs, const Circle &rhs)
{
	return lhs.r == rhs.r && lhs.x == rhs.y && lhs.y == rhs.y;
}
\end{lstlisting}
	Itt az a veszély, hogy ha az STL-es find-al szemben a sajátunkat használjuk, más lehet a végeredmény, hisz a \texttt{Circle}-t ők máshogy hasonlítják össze.
	
	\subsection{STL felépítése}
	Látogassunk el a \url{http://en.cppreference.com/w/} oldalra, és picikét barátkozzunk vele. Itt láthatjuk az összes STL konténert, de sok fontos információhoz is hozzájuthatunk, pl. az \texttt{std::string}-el kapcsolatban is: példaképp az \texttt{std::string} csak egy typename!
	
	Mivel teljesen irreális minden STL algoritmusról részletesen beszélni, így ajánlatos ezeket is nézni: \url{http://en.cppreference.com/w/cpp/algorithm}.
	
	Érdemes megbarátkozni az STL-el: lévén vizsgán lehet használni mindent ami a standard könyvtárban benne van, könnyen megspórolhatjuk a gondolkodást a megfelelő STL algoritmus hívásával.
	
	\medskip
	Rendezzük egy \texttt{vector} elemeit!
	\begin{lstlisting}
std::vector<int> v {6,3,7,4,1,3};
std::set<int> s {6,3,7,4,1,3};
std::set<int> s1(v.begin(), v.end());
v.assign(s1.begin(), s1.end());
for(int i : v)
{
	std::cout << i << ' '; // 1 3 4 6 7 
}
	\end{lstlisting}
	\begin{note}
		Az fenti inicializálások a c++11-es újítás részei, sok magyarázatra gondolom nem szorulnak.
		
		A fenti ciklus szokatlan lehet, ez is egy c++11es újítás, un. \textit{range-based for loop}. A fenti kód ezzel ekvivalens:
		\begin{lstlisting}
int i;
for(std::vector<int>::iterator it = v.begin(); it != v.end(); it++)
{
	i = *it;
	std::cout << i << ' ';
}
		\end{lstlisting}
		Számunkra legyen elég most annyi, hogy az így írt ciklusok akkor működnek, ha a jobb oldalon álló objektum (most \texttt{v}) rendelkezik \texttt{begin()} és \texttt{end()} tagfüggvényekkel, vagy pedig az objektum egy tömb. Ez nem a teljes lista, de most legyen egyenlőre ennyi elég.
	\end{note}
	Most kihasználtuk, hogy az \texttt{std::set} alapértelmezetten rendezett: átpakoljuk abba, majd vissza. No persze, ez minden, csak nem hatékony. Továbbá feltűnhet, hogy az egyik 3-as kiesett: az \texttt{std::set} kiszűrte az egyiket, mert ekvivalens elemet nem tárol. Ennél sokkal hatékonyabb, ha egy STL algoritmussal dolgozunk:
	\begin{lstlisting}
std::vector<int> v {6,3,7,4,1,3};
std::sort(v.begin(), v.end());
for(int i : v)
{
	std::cout << i << ' '; // 1 3 3 4 6 7 
}
	\end{lstlisting}
	Fontosabb algoritmusok:
	\begin{compactitem}
		\item find
		\item search
		\item sort
		\item reverse
		\item rotate
		\item unique
		\item remove
		\item stb...
	\end{compactitem}
	Beszéljünk is ez utóbbiról!
	
	\url{http://en.cppreference.com/w/cpp/algorithm/remove}
	\begin{lstlisting}
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
	std::vector<int> v{1,2,3,3,4,5,6};
	std::cout << v.size() << std::endl;
	std::remove(v.begin(), v.end(), 3);
	std::cout << v.size() << std::endl;
}
	\end{lstlisting}
	Legnagyobb meglepetésünkre, ez semmit se fog törölni: az \texttt{std::remove} átrendezi a konténert, úgy hogy a konténer elején legyenek a nem törlendő elemeket, és utána a törlendőek, és az első törlendő elemre visszaad egy iterátort. Ennek segítségével tudjuk, hogy ettől az iterátortól a \textit{past-the-end iterator}-ig minden törlendő.
	\begin{lstlisting}
std::vector<int> v{1,2,3,3,4,5,6};
std::cout << v.size() << std::endl;
auto it = std::remove(v.begin(), v.end(), 3);
v.erase(it, v.end());
std::cout << v.size() << std::endl;
	\end{lstlisting}
	\begin{note}
		Ebben a kódban van pár c++11-es újítás is: az \texttt{auto} kulcsszó megadható konkrét típus helyett. Ilyenkor az egyenlőségjel bal oldalán lévő objektum típusára helyettesítődik a kulcsszó. Példaképp, fent a fordító meg tudja határozni, hogy az \texttt{std::remove}-nak a visszatérési értéke itt \texttt{std::vector<int>::iterator} lesz, így a kód azzal ekvivalens, mintha ezt írtuk volna:
		
		{\centering\texttt{std::vector<int>::iterator it = std::remove(v.begin(), v.end(), 3);} \par}
		
		Bár az \texttt{auto} kulcsszót sokáig lehetne még boncolgatni, legyen annyi elég egyenlőre, hogy a template paraméter dedukciós szabályok szerint működik: azaz a const/volatile tulajdonságok \textit{(c/v qualifiers)} elvesznek közben. (c++11et nem szükséges tudni a vizsgához)
	\end{note}
	
	\medskip
	Megjegyzendő, hogy nem minden algoritmus működik minden iterátor típussal, és vannak egyes algoritmusokank speciális előfeltétele: például az \texttt{std::unique} egy rendezett konténert vár. Megjegyzendő még, hogy két különböző rendező algoritmusunk is van: \texttt{std::sort} és \texttt{std::stable\_sort}. AZ utóbbi garantálja, hogy az ekvivalens elemek relatív sorrendje ne vltozzon (pl. korábbi példában az \texttt{ADA} és a \texttt{C++}, melyek ekvivalensek, de nem egyenlőek).
	
	Fontos az is, hogy ezek az algoritmusok általában nagyon hatékonyak, így gyakran nem is érdemes sajt magunktól megírni.
	
	\medskip
	Fent kiírtam hogy \texttt{std::remove}, de ebből a namespace-t elhagyhatom.
	\begin{lstlisting}
//...
auto it = remove(v.begin(), v.end(), 3);
//...
	\end{lstlisting}
	Itt a fordító a függvény paraméterekből ki tudja találni (\textit{Argument Dependent Lookup, ADL}), hogy milyen névtérből van az algoritmus. Mivel a \texttt{vector} ugyanúgy az \texttt{std} névtérből származik, és azt adtunk meg paraméternek, tudni fogja a fordító, hogy a \texttt{remove}-ot is abban a névtérben kell keresni.
	
	\bigskip
	
	Vegyünk egy konténert, és jelöljünk meg benne bár elemet, melyektől azt szeretnénk, hogy legyenek egymás mellett, de minden más elem sorrendje ne változzon.
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&*&&*&*&&*\\
			\hline
		\end{tabular}
		
		$\Downarrow$
		
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&*&*&*&*&&\\
			\hline
		\end{tabular}
	\end{center}
	Próbáljuk a csillaggal jelölt elemet egymás mellé tenni: ezt megtehetjük pl. két \texttt{stable\_partition}-nel, mert az ekvivalens elemek sorrendjét nem változtatják. 
	
	Most csináljuk azt, hogy a kijelölt elemek a konténer végén legyenek, de a többi elem sorrendje ne változzon! Itt használhatjuk az előbbi algoritmusok után az \texttt{std::rotate}-et.
	\begin{center}
		
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&*&*&*&*&&\\
			\hline
		\end{tabular}
		
		$\Downarrow$
		
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			&&&&*&*&*&*\\
			\hline
		\end{tabular}
	\end{center}
	A legtöbb algoritmusnál, mely visszatér egy iterátorral, úgy jelzik, hogy az adott elemet nem találtak meg (stb), hogy egy \texttt{past-the-end} iterátort adnak vissza.
	%TODO jobb struktúrálás.
	\begin{center}
		\textit{,,Általában az emberek nem szeretik, hogyha kicsesznek velük, és ha kicseszel a kollégáiddal, morcosak lesznek''}
		
		/Horváth Gábor/
	\end{center}
\end{document}
