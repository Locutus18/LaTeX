\documentclass[a4paper,11.5pt,table]{article}
\usepackage[textwidth=170mm, textheight=230mm, inner=20mm, top=20mm, bottom=30mm]{geometry}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{amsmath, amsthm,amssymb, paralist, tikz, multirow}
\usetikzlibrary{arrows, positioning}

\usepackage{listings}
\lstset{
	language=C++, 
	basicstyle=\ttfamily, 
	keywordstyle=\color{blue}\ttfamily, 
	stringstyle=\color{red}\ttfamily,
	tabsize = 4
}

\usepackage{hyperref}

\begin{document}
	%%%%%%%%%%%RÖVIDÍTÉSEK%%%%%%%%%%
	\setlength\parindent{0pt}
	\def\<{<\hspace{0mm}<}
	
	\theoremstyle{definition}
	\newtheorem{note}{Megjegyzés}[subsection]
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\begin{center}
		{\LARGE\textbf{C++}}
		
		{\Large Gyakorlat jegyzet}
		
		6. óra.
	\end{center}
	A jegyzetet \textsc{Umann} Kristóf készítette \textsc{Horváth} Gábor gyakorlatán. (\today)
	\subsection{Értékadó operátor}
	Másoló konstruktorunk már van, de az értékadással még mindig lábon lőhetjük magunkat. Hasonlóan a default másoló konstruktorhoz, alapértelmezetten az értékadás operátor (\textit{assignment operator}, vagy röviden \texttt{=}) is bitről bitre másol, így jobb ha felülírjuk.
\begin{lstlisting}
struct List
{
	//...
	
	//copy constructor
	List(const List &other) : data(other.data), next(0)
	{
		if (other.next != 0)
		{
			next = new List(*other.next);
		}
	}
	
	//assignment operator
	List& operator=(const List &other)
	{
		delete next;
		data = other.data;
		if (other.next) // if(other.next) == if(other.next != 0)
		{
			next = new List(*other.next);
		}
		else
		{
			next = 0;
		}
		return *this;
	}
	
	//...
};
\end{lstlisting}
	Az új értékadás operátorunk először kitörli az aktuális lista elemeit, majd rekurzív módon átmásolja \texttt{other} elemeit az aktuális listába.
	
	Példaképp, a legelső lépés a \texttt{delete next;}-el az összes aktuális listaelem felszabadítása, majd addig hívjuk meg az értékadást rekurzívan, míg az \texttt{other} lista végére nem érünk (erre van az \texttt{if} ág), és ha elértünk oda, akkor zárjuk le az aktuális listát egy nullpointerrel. 
	
	Sikerült elérnünk, hogy ha lemásoljuk a listát, és a másolatot módosítjuk, az eredeti lista nem fog változni.
	\medskip
	
	Figyeljök meg, hogy referenciával tértünk vissza. Ennek oka az, hogy meg tukjuk tenni ezt:
	\begin{lstlisting}
			int a = b = c = d = 0; // a = (b = (c = (d = 0)))
	\end{lstlisting}
	Itt rendre \texttt{d}-t, \texttt{c}-t, \texttt{b}-t, \texttt{a}-t adjuk vissza, így egymásba fűzhetjük az értékadást.
	\begin{note}
		Miért nem konstans referenciával térünk vissza? Azért, mert nem tehetnénk meg ezt: (legyen \texttt{f} egy nem konstanst váró függvény) \texttt{f(a = 0)}.
	\end{note}
	
	Írjunk egy egyszerűbb kiíratást is!
	\begin{lstlisting}
struct List
{
	//...
	
	void print ()
	{
		std::cout << data << ' ';
		if (next)
			next->print();
	}
	
	//...
};
	\end{lstlisting}
	Nézzük meg mit műveltünk!
	\begin{lstlisting}
int main ()
{
	List head(7);
	head.add(8);
	head.add(2);
	{
		List cHead = head;
	}
	head.print();
}
	\end{lstlisting}
	Kimenet: \texttt{7 8 2}
	
	Azonban itt még mindig van egy nagy veszély. Ha a listát saját magának adjuk értékül, akkor a legelső lépés továbbra is az, hogy kitöröljük az aktuális lista elemét. így \texttt{cHead = cHead} megsemmisíti önmagát, és use-after-free hibát követnénk el, amikor a destruktor lefut. Persze mondhatnánk, hogy ki az a hülye, aki ilyen csinálna, de sajnos ezt a hibát könnyebb elkövetni mint gondolnánk.
	\begin{lstlisting}
void f(List &l1, List &l2)
{
	//...
	l1 = l2;
	//...
}
	\end{lstlisting}
	Ha valaki ugyanazt a listát adja meg mindkét paraméternek, akkor máris megvan a baj. Módosítsuk az értékadás operátorunkat:
\begin{lstlisting}
List& operator=(const List &other)
{
	if (this == &other) return *this;
	delete next;
	if (other.next)
	{
		next = new List(*other.next);
	}
	else
	{
		next = 0;
	}
	return *this;
}
\end{lstlisting}
	Ezzel a probléma el is lett kerülve. Újdonság lehet a \texttt{this} kulcssszó -- ennek segítségével tudunk rámutatni tagfüggvényen belül az adott objektumra. Segíthet a megértésben, ha úgy tekintünk rá, hogy \texttt{head.print()} esetében például sehogyse tudnánk \texttt{print()}-en belül \texttt{head}-re hivatkozni, hisz az objektum neve tagfüggvényen belül nem elérhető. Ezt a problémát hivatott a \texttt{this} kulcsszó orvosolni. \texttt{this} egy konstans pointer, mely az objektum címére mutat.
	\medskip

	Sikeresen létrehoztunk egy \textit{reguláris típust}.
	\medskip
	
	Egy \texttt{T} típus \textbf{reguláris típus}, ha van neki:
	\begin{enumerate}
		\item konstruktora
		\item destruktora
		\item értékadás operátora, továbbá
		\begin{lstlisting}
T b;
T a;
a = b;
		\end{lstlisting}
		Ekkor \texttt{a} ekvivalens \texttt{b}-vel, és ha \texttt{a}-t módosítjuk, akkot \texttt{b} nem változik, és viszont.
		\item másoló konstruktora, továbbá
		\begin{lstlisting}
T b;
T a = b;
		\end{lstlisting}
		Ekkor \texttt{a} ekvivalens \texttt{b}-vel, és ha \texttt{a}-t módosítjuk, akkot \texttt{b} nem változik, és viszont.
		\item egyenlőségvizsgálat (\texttt{operator==}) (nem feltétlenül szükséges)
	\end{enumerate}
	\subsection{Adattagok védettsége}
	Már majdnem készen vagyunk, ám a hülye felhasználó még mindig lábon lőheti magát, pl így:
	\begin{lstlisting}
int main()
{
	List head(8);
	head.add(7);
	head.add(2);
	head.next = 0;
}
	\end{lstlisting}
	Itt az első listaelem utáni elemeket lecsatoljuk, és azoknak a memóriája elszivárog. A baj probléma az, hogy a \textbf{felhasználó hozzáfér az adattagokhoz.} A felhasználó így nagy hülyeséget csinálhat, továbbá ha gyakran hivatkozik belső adattagokra, egyéb baja is lehet. Példaképp, ha a \texttt{List} \texttt{next} adattagjának új nevet adunk, akkor át kéne írni minden olyan kódot ami \texttt{next}re hivatkozik.
	
	Jó lenne, ha hiába változna a belső reprezentáció, a kódnak nem kéne változnia. 
	
	Írjuk át ezt úgy, hogy a felhasználó ne férjen hozzá az adattagokhoz!

\begin{lstlisting}
class List //nem struct!
{
public:
	List(int data, List *next = 0) : //...
	void add(int data) {//...}
	List(const List &other) //...
	List& operator=(const List &other) {//...}
private:
	int data;
	List *next;
};
\end{lstlisting}
	Az osztály minden adattagja, metódusa mely a \texttt{public} kulcsszó után jön, elérhető bárki számára. A \texttt{private} kulcsszó után következő adatok csak is kizárólag az adott osztályon belül érhető el (nemsokára megismerkedünk egy kivétellel).

	A \texttt{class} majdnem ugynaz mint a \texttt{struct}, csak alapértelmezetten a \texttt{struct} minden adattagja és tagfüggvénye publikus, míg \texttt{class}-nak alapértelmezetten privát. A \texttt{public} ill. \texttt{private} kulcsszóval mind a kettőnél szabályozhatjuk a privát és publikust részt.
	
	\medskip
	Azonban van egy igen nagy probléma, ami ennek a módosításnak a követekzménye lett. Például az, hogy így sose tudunk hozzáférni a második elemhez kívülről. Vagy bármelyik másikhoz. Ilyenkor megoldás lehet az, ha módosítjuk a listát, és minden olyan függvényt,  aminek hozzá kéne férnie az elemekhez, metódussá tesszük, hisz a lista metódusai hozzáférnek a privát adattagokhoz is.
	
	Najó, ezt minden egyes függvénnyel lehet nem akarjuk megtenni. A végén egy kilóméter implementációnk lenne, ami nagyon rontaná az olvashatóságot.
	
	Írjunk felsorolót erre a célra, és utána meglátjuk hogy
	\begin{center}
		\textit{,,az úgy hülyeség ahogy van.''}
		
		/Horváth Gábor/
	\end{center}
\begin{lstlisting}
class List
{
	//...
	
	void First()
	{
		cursor = this;
	}
	int& Current()
	{
		return cursor->data;
	}
	void Next()
	{
		cursor = cursor->next;
	}	
	bool End()
	{
		return cursor == 0;
	}
	
private:
	int data;
	List *next;
	List *cursor;
};
\end{lstlisting}
	Figyeljük meg, hogy \texttt{Current()} referenciával tér vissza, hogy ne \texttt{data} másolatát, hanem magát a \texttt{data}-t kapjuk meg, így tudjuk a lista értékét módosítani.
	
	\medskip
	Első látásra a problémát orvosoltuk, tudunk a listákkal tárolt adatokkal dolgozni (pl. összeadni őket, stb). De egy rendezésnél már bajban lehetünk. Például csak 1 darab kurzorunk van, így nem tudunk egyszerre 2 elemhez hozzáférni, hogy összehasonlítsuk őket, lévén csak egy \texttt{cursor} van. Megoldás!:
\begin{lstlisting}
class List
{
	//...
	
	void First()
	{
		cursor = this;
	}
	int& Current()
	{
		return cursor->data;
	}
	void Next()
	{
		cursor = cursor->next;
	}	
	bool End()
	{
		return cursor == 0;
	}
	
	void First2()
	{
		cursor2 = this;
	}
	int& Current2()
	{
		return cursor2->data;
	}
	void Next2()
	{
		cursor2 = cursor2->next;
	}	
	bool End2()
	{
		return cursor2 == 0;
	}
	
private:
	int data;
	List *next;
	List *cursor;
	List *cursor2;
};
\end{lstlisting}
	Oké, ez viccnek talán jó, de könnyű látni, ha mondjuk 3 darab \texttt{cursor} kéne, akkor bajba lennénk, és hosszútávon nem ez a jó hozzáállás. Ez nem elég ahhoz, hogy komplex feladatokat meg tudjunk írni. \textbf{Munkahelyen ilyet ne írjunk!} Töröljük is ki gyorsan, és írjunk egy iterátort!
	\subsection{Iterátorok}
	Az iterátorok a pointerek általánosítása, segítségükel tudunk végigiterálni egy konténer elemein (azaz velük tudjuk lekérdezni a konténer elemeit). Ehhez szükségünk van arra, hogy tudjuk hol kezdődik és végződik a konténerünk. E láncolt lista esetében hozzá tudunk férni az első elemhez (az lesz ugye \texttt{head} a fenti példákban) és tudjuk hogy mindig nullpointerrel végződik. Legyen az iterátunk neve \texttt{Iterator}!
\begin{lstlisting}
class List
{
	//...
public:
	Iterator begin()
	{
		return Iterator(this);
	}
	Iterator end()
	{
		return Iterator(0);
	}
};
\end{lstlisting}
	E két metódus segítségével már meg tudjuk adni a lista elejét és végét! \texttt{head.begin()} lesz \texttt{head} a legelső eleme, \texttt{head.end()} az utolsó utáni elem. Már csak magát az iterátort kell megírni, mely egy un. \textit{forward iterator} lesz.
	\medskip

	Egy \texttt{T} típus \textbf{forward iterator}, ha rendelkezik:
	\begin{enumerate}
		\item \texttt{++} operátorral
		\item egyenlőség vizsgáló operátorral \texttt{==}
		\item egyenlőtlenség vizsgáló operátorral \texttt{!=}
		\item dereferáló operátorral \texttt{*}
	\end{enumerate}
	De hova írjuk az \texttt{Iterator} osztályt? Hiszen ha a lista elé tesszük, az \texttt{Iterator} nem fogja tudni, hogy mi az a \texttt{List}. Ha utána tesszük, nem fogja tudni a \texttt{List} hogy mi az az \texttt{Iterator}, úgy meg nem műküdne az \texttt{end} és a \texttt{begin} metódus. Ehhez \textbf{forward deklarálni} fogunk.
	\begin{lstlisting}
class List; //forward declaration

class Iterator
{
public:
	Iterator(List *_p) : p(_p) {}
	bool operator==(Iterator &other)
	{
		return p == other.p;
	}
	bool operator!=(Iterator &other)
	{
		return !(*this == other);
	}
	//...
private:
	List *p; //(*)
};

class List {//...};
	\end{lstlisting}
	A fordító már a csillagozott sornál nem fog problémázni, hogy nem tudja mi az a \texttt{List} - arra számít hogy valamikor (akár egy másik fordítási egységben) \texttt{List} definiálva lesz. Amennyiben nem akarjuk dereferálni \texttt{p}-t, elég csupán a forward deklarálni, ki sem kell fejtenünk az osztály bővebben később!
	
	\medskip
	Még hiányzik a \texttt{++} és a \texttt{*} operátorunk.
\begin{lstlisting}
class List;

class Iterator
{
public:
	Iterator(List *_p) : p(_p) {}
	bool operator==(Iterator &other)
	{
		return p == other.p;
	}
	bool operator!=(Iterator &other)
	{
		return !(*this == other);
	}
	Iterator operator++()
	{
		p = p->next;
		return *this;
	}
	int& operator*()
	{
		return p->data;
	}
private:
	List *p;
};

class List {//...};
\end{lstlisting}
%TODO operator++ miért nem referenciával tér vissza?
	És itt az előbb említett problémába bele is ütköztünk: a fordító siránkozik, hogy a \texttt{List} egy un. \textit{incomplete type}. Ugyanis az tudja hogy van osztály hogy \texttt{List}, de az, hogy \texttt{next} adattag, nem tudja micsoda. Ezért ezeket a tagfüggvényeket a lista után kell írni.
\begin{lstlisting}
class List;

class Iterator
{
public:
	Iterator(List *_p) : p(_p) {}
	bool operator==(Iterator &other)
	{
		return p == other.p;
	}
	bool operator!=(Iterator &other)
	{
		return !(*this == other);
	}
	Iterator operator++();
	int& operator*();
private:
	List *p;
};

class List {//...};

Iterator Iterator::operator++()
{
	p = p->next;
	return *this;
}
int& Iterator::operator*()
{
	return p->data;
}
\end{lstlisting}
	Itt még mindig hisztizni fog a fordító: \texttt{next} és \texttt{data} annyira private, hogy még az \texttt{Iterator} se fér hozzá! Erre megoldás, hogyha \textbf{barát} (\textit{friend}) osztállyá tesszük.
	\begin{lstlisting}
class List
{
	//...
	friend class Iterator;
	//...
}
	\end{lstlisting}
	A barátként deklarált osztályok és függvények hozzá tudnak férni az osztály privát adattagjaihoz is.
	
	\smallskip
	Az így kapott iterátorunkkal végig tudunk menni a lista elemein, hozzá tudunk férni az adattagjaihoz. Így már azt is megtehetjük, hogy \texttt{print()}-et tagfüggvény helyett sima globális függvénnyé tesszük.
	\begin{lstlisting}
void print(List &l)
{
	for(Iterator it = l.begin(); it != l.end(); ++it)
	{
		std::cout << *it << ' ';
	}
	std::cout << std::endl;
}
	\end{lstlisting}
	Ez a függvény, csak úgy mint az \textit{STL} függvények is (majd lesz még boncolgatva az, hogy mi az az \textit{STL}), balról zárt, jobbról nyitott $[\ )$ intervallummal dolgoznak. Azaz az \texttt{end()} már nem eleme a listának, az az utolsó \textit{utáni} elem (\texttt{past-the-end iterator}).
	
	\medskip
	Megint nyertünk! Annyi \texttt{Iterator}-t hozunk létre, amennyit csak akarunk, nem vagyunk korlátozva egy darab \texttt{cursor} által. Továbbá, elég azt írni, hogy \texttt{.begin(), .end()}, nem kell tudnunk, mi van az implementáció mélyén, \textbf{sőt}, a belső implementáció változhat is, akkor se lesz baj. Két programozó így teljesen jól együtt tud dolgozni.
	
	\medskip
	Megfigyelhető, hogy \texttt{print} nem módosítja a paraméterként kapott listát, így átvehetnénk konstansként is. Ennek az eredménye egy kilóméter fordítási hiba: amit az \texttt{end} és \texttt{begin} visszaad, nem konstans, azaz ezeken keresztül tudjuk módosítani az objektumot. Valahogy törekednünk kéne arra, hogy a konstans korrektséget betartsuk.
	\subsection{Konstans iterátorok}
	Erre a megoldás, ha konstans iterátort írunk, ami egy konstansra mutató mutató általánosítása.
\begin{lstlisting}
class List;

class Iterator
{
	//...
};

class ConstIterator
{
public:
	Const Iterator(const List *_p) : p(_p) {}
	bool operator==(ConstIterator &other) const //a metodus konstans!
	{
		return p == other.p;
	}
	bool operator!=(ConstIterator &other) const
	{
		return !(*this == other);
	}
	Iterator operator++();
	int operator*() const; //nem referenciaval ter vissza!
private:
	const List *p; //konstanra mutato pointer!
};

class List
{
	//...
	ConstIterator begin() const
	{
		return ConstIterator(this);	
	}
	ConstIterator end() const
	{
		return ConstIterator(0);	
	}
	//...
};

Iterator Iterator::operator++() {//...}
int& Iterator::operator*() {//...}

ConstIterator ConstIterator::operator++()
{
	p = p->next;
	return *this;
}
int ConstIterator::operator*() const
{
	return p->data;
}
\end{lstlisting}
	Azon a metódusok, amik után \texttt{const} van írva (ld. fenti példa) nem tudják megváltoztatni az osztály adattagjait. Ezeket a metódusokat \textbf{konstans metódusok}nak (\textit{const method}) hívják. Egy konstans objektumon csak akkor lehet meghívni egy metódust, ha az a metódus konstans.
	\begin{note}
		Ami lehet \texttt{const}, az \textbf{legyen} \texttt{const}!
	\end{note}

	Egy \texttt{const List} típusú objektum a konstans függvényt fogja meghívni, így \texttt{begin()} visszatérési értékének típusa \texttt{ConstIterator} lesz, míg egy nem konstans \texttt{List} objektumnál \texttt{Iterator} lenne. Érdemes egyébként minden metódust, mely nem változtatja az adattagokat konstansként deklarálni. 
	\begin{lstlisting}
int main()
{
	List head(8);
	head.add(7);
	head.add(2);
	{
		ConstIterator cit = it.begin(); //hiba
	}
}
	\end{lstlisting}
	Két különböző típust nem tudunk egymásnak értékül adni, azonban ez a két típus közel megyezik, így egy új konstrukorral ezt könnyen tudnánk orvosolni.
	\begin{lstlisting}
class ConstIterator
{
	//...
public:
	ConstIterator(Iterator &other) : p(other.p) {}
	//...
}
	\end{lstlisting}
	Itt már csak annyi probléma lesz, hogy \texttt{Iterator}-nak a \texttt{p} adattagja privát. Így tegyük ezt a két osztályt baráttá!
	
	Azonban az meglepő lehet, hogy ez a kód lefordul. Hiszen \texttt{head.begin()} egy \texttt{Iterator}-t ad vissza, hiszen \texttt{head} nem konstans! Ezt a fordító úgy oldja meg, hogy az így kapott \texttt{Iterator} típusú változóval használja a \texttt{ConstIterator} konstruktorát, ezzel \textit{implicit kódon átkonvertálja} \texttt{Iterator}-t \texttt{ConstIterator}-rá, és utána hívja meg a másoló konstruktort. 
	
	\subsection{Explicit konstruktorok}
	Ezt megtilthatjuk a fordítónak, ha az \texttt{explicit} kulcsszót betesszük a konstruktor elé.
	
\begin{lstlisting}
class ConstIterator
{
	//...
public:
	explicit ConstIterator(Iterator &other) : p(other.p) {}
	//...
}
\end{lstlisting}
	Persze, ezt itt nem akarjuk megtiltani, lévén az \texttt{Iterator} és a \texttt{ConstIterator} majdnem ugyanaz, itt szeretnénk ha tudna implicit konvertálódni. De mi az, ami nagyon nagy hiba volt? A \texttt{List}-nél kellett volna használni ezt! Ha lenne egy függvény, ami egy listát vár paraméterül, egy darab \texttt{int}-et is elfogadott volna, hisz a \texttt{List} konstruktorát felhasználva tudott volna csinálni abból az \texttt{int}-ből egy egy elemű listát! Így gyorsan tegyük a \texttt{List} konstruktorát \texttt{explicit}-té.
	\begin{lstlisting}
class List
{
	//...
	explicit List(const int _data, List *_next) : data(_data), next(_next) {}
	//...
}
	\end{lstlisting}
\end{document}
