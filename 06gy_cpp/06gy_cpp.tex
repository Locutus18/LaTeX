\documentclass[a4paper,11.5pt,table]{article}
\usepackage[textwidth=170mm, textheight=230mm, inner=20mm, top=20mm, bottom=30mm]{geometry}
\usepackage[normalem]{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{amsmath, amsthm,amssymb, paralist, tikz, multirow}
\usetikzlibrary{arrows, positioning}

\usepackage{listings}
\lstset{
	language=C++, 
	basicstyle=\ttfamily, 
	keywordstyle=\color{blue}\ttfamily, 
	stringstyle=\color{red}\ttfamily,
	tabsize = 4
}

\usepackage{hyperref}

\begin{document}
	%%%%%%%%%%%RÖVIDÍTÉSEK%%%%%%%%%%
	\setlength\parindent{0pt}
	\def\<{<\hspace{0mm}<}
	
	\theoremstyle{definition}
	\newtheorem{note}{Megjegyzés}[subsection]
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\begin{center}
		{\LARGE\textbf{C++}}
		
		{\Large Gyakorlat jegyzet}
		
		6. óra.
	\end{center}
	A jegyzetet \textsc{Umann} Kristóf készítette \textsc{Horváth} Gábor gyakorlatán. (\today)
	\subsection{Értékadó operátor}
  Az előző órán elkészült másoló konstruktor megoldotta a probléma egy részét, de az értékadással hasonló problémák merülnek fel. Hasonlóan a fordító által generált másoló konstruktorhoz, az alapértelmezetten az értékadás operátor (\textit{assignment operator}, vagy röviden \texttt{=}) is meghívja az egyes tagok értékadó operátorait, amik a primitív típusok esetén bitről bitre másolnak.
\begin{lstlisting}
struct List
{
	// ...
	
	// copy constructor
	List(const List &other) : data(other.data), next(0)
	{
		if (other.next != 0)
			next = new List(*other.next);
	}
	
	// assignment operator
	List& operator=(const List &other)
	{
		delete next;
		data = other.data;
		if (other.next) // if(other.next) == if(other.next != 0)
			next = new List(*other.next);
		else
			next = 0;
		return *this;
	}
	
	//...
};
\end{lstlisting}
	Az új értékadás operátor először kitörli az aktuális lista elemeit, majd rekurzív módon lemásolja az \texttt{other} elemeit.
	
  Kicsit részletesebben: az első lépés a \texttt{delete next;}, a fejelemet leszámítva felszabadítja az összes többi listaelemhez tartozó memóriaterületet, eztán lemásoljuk az \texttt{other} fejelemében lévő adatot. Végül a másoló konstruktorhoz hasonlóan rekurzív módon lemásoljuk az \texttt{other} farokrészét (amennyiben az létezik).
	
  Azáltal, hogy egy listaelem másolásakor az összes listaelem által birtokolt (heapen lévő) objektum is másolásra kerül, elértük azt, hogy a másolaton végzett módosításoknak ne legyen hatása az eredeti objektumra.
	\medskip
	
	Figyeljük meg, hogy az értékadás operátorban egy az adott objektumra mutató referenciával tértünk vissza. Ennek oka az, hogy szeretnénk, ha lehetséges lenne az értékadások láncolása:
	\begin{lstlisting}
			int a = b = c = d = 0; // a = (b = (c = (d = 0)))
	\end{lstlisting}
  Itt rendre (az operátorok kiértékelési sorrendjét tekintve) \texttt{d}-re, \texttt{c}-re, \texttt{b}-re, \texttt{a}-ra mutató referenciát ad vissza az értékadás operátor, így a végeredmény az lesz, hogy mindegyik változót 0-ra inicializáltuk.
	\begin{note}
    Miért nem konstans referenciával térünk vissza? Akkor nem csinálhatnánk hasonlót: (legyen \texttt{f(int \&)}) \texttt{f(a = 0)}.
	\end{note}
	
	Egyszerűsítsük a lista kiírását is!
	\begin{lstlisting}
struct List
{
	//...
	
	void print ()
	{
		std::cout << data << ' ';
		if (next)
			next->print();
	}
	
	//...
};
	\end{lstlisting}
	Ellenőrizzük, hogy az eredeti elemek nem változtak a másolás következtében!
	\begin{lstlisting}
int main ()
{
	List head(7);
	head.add(8);
	head.add(2);
	{
		List cHead = head;
	}
	head.print();
}
	\end{lstlisting}
	Kimenet: \texttt{7 8 2}
	
	Elértük, hogy biztonságos legyen a lista használata? Most már látszólag a másolás és az értékadás sem okozhat memóriakezeléssel kapcsolatos problémát. Van egy eset, amire a kód még nincs felkészítve! Mi történik, ha önmagának adjuk értékül a listát? Az első lépésben törlésre fog kerülni a fejelemet leszámítva minden elem. Eztán a következő lépésekben már felszabadított memóriaterületetről próbáljuk átmásolni a megfelelő adatokat. A \texttt{cHead = cHead} tehát use-after-free hibát fog okozni. Mennyire valós a félelem ettől a hibától? Hiszen nem gyakran adunk értékül egy objektumot önmagának! Tekintsük a következő függvényt:
	\begin{lstlisting}
void f(List &l1, List &l2)
{
	//...
	l1 = l2;
	//...
}
	\end{lstlisting}
	Ha valaki ugyanazt a listát adja meg mindkét paraméternek, akkor máris megvan a baj. Látható tehát, hogy ilyen jellegű hibát nem feltétlen olyan nehéz elkövetni.  Módosítsuk az értékadás operátorunkat oly módon, hogy ne okozzon problémát az önértékadás:
\begin{lstlisting}
List& operator=(const List &other)
{
	if (this == &other) return *this;
	delete next;
	if (other.next)
		next = new List(*other.next);
	else
		next = 0;
	return *this;
}
\end{lstlisting}
  Emlékezzünk, a \texttt{this} kulcssszó segítségével tudunk rámutatni tagfüggvényen belül az adott objektumra, amin a tagfüggvény meghívásra került. Tulajdonképpen arról van szó, hogy például a \texttt{head.print()} esetében enélkül a kulcsszó nélkül nem tudnánk \texttt{print()}-en belül \texttt{head}-re hivatkozni. Az objektum neve tagfüggvényen belül nem elérhető. A \texttt{this} egy pointerként is felfogható, mely a \texttt{head} objektumra mutat.
	\medskip

	Sikeresen létrehoztunk egy félig \textit{reguláris típust}.
	\medskip
	
	Egy \texttt{T} típus \textbf{reguláris típus}, ha van neki:
	\begin{enumerate}
		\item defualt konstruktora
		\item destruktora
		\item értékadás operátora, továbbá
		\begin{lstlisting}
T b;
T a;
a = b;
		\end{lstlisting}
		Ekkor \texttt{a} ekvivalens \texttt{b}-vel, és ha \texttt{a}-t módosítjuk, akkot \texttt{b} nem változik, és viszont.
		\item másoló konstruktora, továbbá
		\begin{lstlisting}
T b;
T a = b;
		\end{lstlisting}
		Ekkor \texttt{a} ekvivalens \texttt{b}-vel, és ha \texttt{a}-t módosítjuk, akkot \texttt{b} nem változik, és viszont.
		\item egyenlőségvizsgálat (\texttt{operator==}) (Ha nincs, akkor az adott típust félig regulárisnak nevezzük)
	\end{enumerate}
	\subsection{Adattagok védettsége}
	Biztonságossá sikerült tenni a lista használatát? A felhasználó most már a megfelelő metódusok, valamint a másolás és értékadás használatával nem tud elkövetni memóriakezeléssel kapcsolatos hibát. Az adattagokhoz azonban továbbra is hozzá fér. Így, a következő módon továbbra is érhetik meglepetések:
	\begin{lstlisting}
int main()
{
	List head(8);
	head.add(7);
	head.add(2);
	head.next = 0;
}
	\end{lstlisting}
	Itt az első listaelem utáni elemeket lecsatoljuk, és azoknak a memóriája elszivárog. A probléma forrása az, hogy a \textbf{felhasználó hozzáfér az adattagokhoz.} A felhasználó így olyan állapotba állíthatja az adott objektumot, amire az objektum tagfüggvényei nincsenek felkészülve. Másik probléma, hogy a felhasználó azáltal, hogy hozzáfér az adattagokhoz, ki tudja használni a lista belső reprezentációját. Emiatt nehezebben fenntarthatóvá válik a kód, mivel a lista reprezentációját érintő változtatások esetén a felhasználói kódokat is módosítani kell. Példaképp, ha a \texttt{List} \texttt{next} adattagjának új nevet adunk, akkor át kéne írni minden olyan kódot ami \texttt{next}re hivatkozik.
	
	Jó lenne, ha hiába változna a belső reprezentáció, a kódnak nem kéne a felhasználói kódnak változnia. 
	
	Rejtsük el az adattagokat a felhasználó elől!

\begin{lstlisting}
class List // lehetne struct is
{
public:
	List(int data, List *next = 0) : //...
	void add(int data) {//...}
	List(const List &other) //...
	List& operator=(const List &other) {//...}
private:
	int data;
	List *next;
};
\end{lstlisting}
  Az osztály minden tagja, mely a \texttt{public} kulcsszó után jön, elérhető bárki számára. A \texttt{private} kulcsszó után következő adatok csak is kizárólag az adott osztályon belül érhető el (leszámítva a \texttt{friend}eket, de erről később).

	A \texttt{class} és a \texttt{struct} abban tér el, hogy alapértelmezetten a \texttt{struct} minden tagja publikus, míg \texttt{class}-nak privát. A \texttt{public} ill. \texttt{private} kulcsszóval mind a kettőnél explicit megadhatjuk a láthatóságot.
	
	\medskip
	Van egy súlyos következménye az imént bevezetett adatrejtésnek. Például, így nem tudunk hozzáférni a második elemhez kívülről. Vagy bármelyik másikhoz. Ilyenkor a naív megoldás az, ha módosítjuk a listát, és minden olyan függvényt, aminek hozzá kéne férnie az elemekhez, metódussá tesszük. Hiszen a lista metódusai hozzáférnek a privát adattagokhoz is.
	
	Ezt ugyanakkor nem akarjuk minden egyes függvénnyel megtenni. A végén nagyra nőne a lista osztály, ami nagyban rontja az kód érthetőségét és fenntarthatóságát. Emellett a reprezentáció változtatásával megint sok függvényt kellene módosítani.
	
	Írjunk felsorolót, amivel hozzáférhetünk az elemekhez kívülről is.
\begin{lstlisting}
class List
{
	//...
	
	void First()
	{
		cursor = this;
	}
	int& Current()
	{
		return cursor->data;
	}
	void Next()
	{
		cursor = cursor->next;
	}	
	bool End()
	{
		return cursor == 0;
	}
	
private:
	int data;
	List *next;
	List *cursor;
};
\end{lstlisting}
	Figyeljük meg, hogy \texttt{Current()} referenciával tér vissza, hogy ne \texttt{data} másolatát, hanem a \texttt{data}-ra hivatkozó referenciát kapjunk meg, így tudjuk a lista elemeinek az értékeit módosítani.
	
	\medskip
	Első látásra a problémát orvosoltuk, tudunk a listákkal tárolt adatokkal dolgozni (pl. összeadni őket, stb). De egy rendezésnél már problémásabb. Ha csak egy kurzorunk van, nem tudunk egyszerre 2 elemhez hozzáférni, hogy összehasonlítsuk őket vagy megcseréljük őket. Egy lehetséges megoldás:
\begin{lstlisting}
class List
{
	//...
	
	void First()
	{
		cursor = this;
	}
	int& Current()
	{
		return cursor->data;
	}
	void Next()
	{
		cursor = cursor->next;
	}	
	bool End()
	{
		return cursor == 0;
	}
	
	void First2()
	{
		cursor2 = this;
	}
	int& Current2()
	{
		return cursor2->data;
	}
	void Next2()
	{
		cursor2 = cursor2->next;
	}	
	bool End2()
	{
		return cursor2 == 0;
	}
	
private:
	int data;
	List *next;
	List *cursor;
	List *cursor2;
};
\end{lstlisting}
	Ezzel már egy rendezést meg tudunk oldani. De talán érezhető, hogy ez nem a legszebb megoldás. Ha három \texttt{cursor} kéne egy algoritmushoz, akkor megint bajban lennénk. Ennél létezik sokkal szofisztikáltabb megoldás.
	\subsection{Iterátorok}
	Az iterátorok a pointerek általánosításai, segítségükel tudunk végigiterálni egy konténer elemein (azaz velük tudjuk lekérdezni a konténer elemeit). Ehhez szükségünk van arra, hogy tudjuk hol kezdődik és végződik a konténerünk. E láncolt lista esetében hozzá tudunk férni az első elemhez (az lesz ugye \texttt{head} a fenti példákban) és tudjuk hogy mindig nullpointerrel az utolsó elemben lévő mutató értéke. Legyen az iterátunk neve \texttt{Iterator}!
\begin{lstlisting}
class List
{
	//...
public:
	Iterator begin()
	{
		return Iterator(this);
	}
	Iterator end()
	{
		return Iterator(0);
	}
};
\end{lstlisting}
	E két metódus segítségével már meg tudjuk adni a lista elejét és végét! A \texttt{head.begin()} vissza fog adni egy iterátort, ami a \texttt{head} a legelső elemére mutat, \texttt{head.end()} az utolsó utáni elem. Már csak magát az iterátort kell megírni, mely egy un. \textit{forward iterator} lesz.
	\medskip

	Egy \texttt{T} típus \textbf{forward iterator}, ha rendelkezik:
	\begin{enumerate}
		\item \texttt{++} operátorral
		\item egyenlőség vizsgáló operátorral \texttt{==}
		\item egyenlőtlenség vizsgáló operátorral \texttt{!=}
		\item dereferáló operátorral \texttt{*}
	\end{enumerate}
	De hova írjuk az \texttt{Iterator} osztályt? Hiszen ha a lista elé tesszük, az \texttt{Iterator} nem fogja tudni, hogy mi az a \texttt{List}. Ha utána tesszük, nem fogja tudni a \texttt{List} hogy mi az az \texttt{Iterator}. Erre szükség van a Listában az \texttt{end} és a \texttt{begin} metódus megírásához. A körkörös függőség feloldása érdekében \textbf{forward deklarálni} fogunk.
	\begin{lstlisting}
class List; //forward declaration

class Iterator
{
public:
	Iterator(List *_p) : p(_p) {}
	bool operator==(Iterator &other)
	{
		return p == other.p;
	}
	bool operator!=(Iterator &other)
	{
		return !(*this == other);
	}
	//...
private:
	List *p; //(*)
};

class List {//...};
	\end{lstlisting}
	A fordító már a csillagozott sornál nem fog problémázni, hogy nem tudja mi az a \texttt{List} - arra számít hogy valamikor (akár egy másik fordítási egységben) \texttt{List} definiálva lesz. Amennyiben nem akarjuk dereferálni \texttt{p}-t, elég csupán a forward deklarálni, ki sem kell fejtenünk az osztály bővebben később!
	
	\medskip
	Még hiányzik a \texttt{++} és a \texttt{*} operátorunk.
\begin{lstlisting}
class List;

class Iterator
{
public:
	Iterator(List *_p) : p(_p) {}
	bool operator==(Iterator &other)
	{
		return p == other.p;
	}
	bool operator!=(Iterator &other)
	{
		return !(*this == other);
	}
	Iterator operator++()
	{
		p = p->next;
		return *this;
	}
	int& operator*()
	{
		return p->data;
	}
private:
	List *p;
};

class List {//...};
\end{lstlisting}
%TODO operator++ miért nem referenciával tér vissza?
	És itt az előbb említett problémába bele is ütköztünk: a fordító siránkozik, hogy a \texttt{List} egy un. \textit{incomplete type}. Ugyanis az tudja hogy van osztály hogy \texttt{List}, de az, hogy \texttt{next} adattag, nem tudja micsoda. Ezért ezeket a tagfüggvényeket a lista után kell írni.
\begin{lstlisting}
class List;

class Iterator
{
public:
	Iterator(List *_p) : p(_p) {}
	bool operator==(Iterator &other)
	{
		return p == other.p;
	}
	bool operator!=(Iterator &other)
	{
		return !(*this == other);
	}
	Iterator operator++();
	int& operator*();
private:
	List *p;
};

class List {//...};

Iterator Iterator::operator++()
{
	p = p->next;
	return *this;
}
int& Iterator::operator*()
{
	return p->data;
}
\end{lstlisting}
	Itt még mindig hisztizni fog a fordító: \texttt{next} és \texttt{data} annyira private, hogy még az \texttt{Iterator} se fér hozzá! Erre megoldás, hogyha \textbf{barát} (\textit{friend}) osztállyá tesszük.
	\begin{lstlisting}
class List
{
	//...
	friend class Iterator;
	//...
}
	\end{lstlisting}
	A barátként deklarált osztályok és függvények hozzá tudnak férni az osztály privát adattagjaihoz is.
	
	\smallskip
	Az így kapott iterátorunkkal végig tudunk menni a lista elemein, hozzá tudunk férni az adattagjaihoz. Így már azt is megtehetjük, hogy \texttt{print()}-et tagfüggvény helyett sima globális függvénnyé tesszük.
	\begin{lstlisting}
void print(List &l)
{
	for(Iterator it = l.begin(); it != l.end(); ++it)
	{
		std::cout << *it << ' ';
	}
	std::cout << std::endl;
}
	\end{lstlisting}
	Ez a függvény, csak úgy mint az \textit{STL} függvények is (majd lesz még boncolgatva az, hogy mi az az \textit{STL}), balról zárt, jobbról nyitott $[\ )$ intervallummal dolgoznak. Azaz az \texttt{end()} már nem eleme a listának, az az utolsó \textit{utáni} elem (\texttt{past-the-end iterator}).
	
	\medskip
	Megint nyertünk! Annyi \texttt{Iterator}-t hozunk létre, amennyit csak akarunk, nem vagyunk korlátozva egy darab \texttt{cursor} által. Továbbá, elég azt írni, hogy \texttt{.begin(), .end()}, nem kell tudnunk, mi van az implementáció mélyén, \textbf{sőt}, a belső implementáció változhat is, akkor se lesz baj. Két programozó így teljesen jól együtt tud dolgozni.
	
	\medskip
	Megfigyelhető, hogy \texttt{print} nem módosítja a paraméterként kapott listát, így átvehetnénk konstansként is. Ennek az eredménye egy kilóméter fordítási hiba: amit az \texttt{end} és \texttt{begin} visszaad, nem konstans, azaz ezeken keresztül tudjuk módosítani az objektumot. Valahogy törekednünk kéne arra, hogy a konstans korrektséget betartsuk.
	\subsection{Konstans iterátorok}
	Erre a megoldás, ha konstans iterátort írunk, ami egy konstansra mutató mutató általánosítása.
\begin{lstlisting}
class List;

class Iterator
{
	//...
};

class ConstIterator
{
public:
	Const Iterator(const List *_p) : p(_p) {}
	bool operator==(ConstIterator &other) const //a metodus konstans!
	{
		return p == other.p;
	}
	bool operator!=(ConstIterator &other) const
	{
		return !(*this == other);
	}
	Iterator operator++();
	int operator*() const; //nem referenciaval ter vissza!
private:
	const List *p; //konstanra mutato pointer!
};

class List
{
	//...
	ConstIterator begin() const
	{
		return ConstIterator(this);	
	}
	ConstIterator end() const
	{
		return ConstIterator(0);	
	}
	//...
};

Iterator Iterator::operator++() {//...}
int& Iterator::operator*() {//...}

ConstIterator ConstIterator::operator++()
{
	p = p->next;
	return *this;
}
int ConstIterator::operator*() const
{
	return p->data;
}
\end{lstlisting}
	Azon a metódusok, amik után \texttt{const} van írva (ld. fenti példa) nem tudják megváltoztatni az osztály adattagjait. Ezeket a metódusokat \textbf{konstans metódusok}nak (\textit{const method}) hívják. Egy konstans objektumon csak akkor lehet meghívni egy metódust, ha az a metódus konstans.
	\begin{note}
		Ami lehet \texttt{const}, az \textbf{legyen} \texttt{const}!
	\end{note}

	Egy \texttt{const List} típusú objektum a konstans függvényt fogja meghívni, így \texttt{begin()} visszatérési értékének típusa \texttt{ConstIterator} lesz, míg egy nem konstans \texttt{List} objektumnál \texttt{Iterator} lenne. Érdemes egyébként minden metódust, mely nem változtatja az adattagokat konstansként deklarálni. 
	\begin{lstlisting}
int main()
{
	List head(8);
	head.add(7);
	head.add(2);
	{
		ConstIterator cit = it.begin(); //hiba
	}
}
	\end{lstlisting}
	Két különböző típust nem tudunk egymásnak értékül adni, azonban ez a két típus közel megyezik, így egy új konstrukorral ezt könnyen tudnánk orvosolni.
	\begin{lstlisting}
class ConstIterator
{
	//...
public:
	ConstIterator(Iterator &other) : p(other.p) {}
	//...
}
	\end{lstlisting}
	Itt már csak annyi probléma lesz, hogy \texttt{Iterator}-nak a \texttt{p} adattagja privát. Így tegyük ezt a két osztályt baráttá!
	
	Azonban az meglepő lehet, hogy ez a kód lefordul. Hiszen \texttt{head.begin()} egy \texttt{Iterator}-t ad vissza, hiszen \texttt{head} nem konstans! Ezt a fordító úgy oldja meg, hogy az így kapott \texttt{Iterator} típusú változóval használja a \texttt{ConstIterator} konstruktorát, ezzel \textit{implicit kódon átkonvertálja} \texttt{Iterator}-t \texttt{ConstIterator}-rá, és utána hívja meg a másoló konstruktort. 
	
	\subsection{Explicit konstruktorok}
	Ezt megtilthatjuk a fordítónak, ha az \texttt{explicit} kulcsszót betesszük a konstruktor elé.
	
\begin{lstlisting}
class ConstIterator
{
	//...
public:
	explicit ConstIterator(Iterator &other) : p(other.p) {}
	//...
}
\end{lstlisting}
	Persze, ezt itt nem akarjuk megtiltani, lévén az \texttt{Iterator} és a \texttt{ConstIterator} majdnem ugyanaz, itt szeretnénk ha tudna implicit konvertálódni. De mi az, ami nagyon nagy hiba volt? A \texttt{List}-nél kellett volna használni ezt! Ha lenne egy függvény, ami egy listát vár paraméterül, egy darab \texttt{int}-et is elfogadott volna, hisz a \texttt{List} konstruktorát felhasználva tudott volna csinálni abból az \texttt{int}-ből egy egy elemű listát! Így gyorsan tegyük a \texttt{List} konstruktorát \texttt{explicit}-té.
	\begin{lstlisting}
class List
{
	//...
	explicit List(const int _data, List *_next) : data(_data), next(_next) {}
	//...
}
	\end{lstlisting}
\end{document}
